<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Analysis of the iOS Bluetooth Stack: BlueTool</title>
  <meta name="description" content="On iOS the Bluetooth stack is split into three layers as shown in Figure 1.  At the top is the CoreBluetooth framework used by iOS app developers and at the ..."> 
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://www.lightbulbone.com/2015/12/27/bluetool.html">
  <link rel="alternate" type="application/rss+xml" title="LightBulbOne" href="https://www.lightbulbone.com/feed.xml" />
</head>

  <body>
    <nav class="navbar navbar-static-top navbar-inverse" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        <!-- <img src="/img/elastic-path-logo.png" width="10" height="10" /> -->
        LightBulbOne
      </a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a href="/">Blog</a>
            </li>
          
        
      </ul>
    </div>
  </div>
</nav>

    <style>
table{
    /*border-collapse: collapse;*/
    border-spacing: 500px;
    border: 1px solid black;
}

th{
    border: 1px solid black;
}

td{
    border: 1px solid black;
}
</style>


<div class="container">
  <div class="blog-main">
    <div class="blog-post">
      <h2 class="blog-post-title">Analysis of the iOS Bluetooth Stack: BlueTool</h2>
      <p class="blog-post-meta">27 December 2015</p>
      <p>On iOS the Bluetooth stack is split into three layers as shown in Figure 1.  At the top is the CoreBluetooth framework used by iOS app developers and at the bottom is the Bluetooth hardware itself.  In between these two layers is a collection of daemons that implement various aspects of the Bluetooth stack.  For example, most Bluetooth Low Energy (BLE) specific functionality is contained in the BTLEServer daemon.  BlueTool is one of the daemons running and is primarily responsible for acting as a bridge between the rest of the Bluetooth stack and the hardware.  It also likely acts as an internal test tool at Apple during development.</p>

<p>All analysis in this article was carried out on a 5th generation iPod Touch running iOS 8.4 (12H143).  My primary focus during analysis was on understanding what functionality BlueTool provides.  I was not actively looking for bugs despite finding a couple.</p>

<table>
  <tbody>
    <tr>
      <td>[[/assets/images/2015/12/iOS-Bluetooth-Overview.png</td>
      <td>alt=”Overview of the iOS Bluetooth stack.”]]</td>
    </tr>
  </tbody>
</table>

<h2 id="bluetool-io-mechanisms">BlueTool I/O Mechanisms</h2>

<p>BlueTool is started automatically at boot by launchd and may also be started manually.  When it is started automatically by launchd, BlueTool is executed with an undocumented <code class="highlighter-rouge">-R</code> flag that can be seen by either inspecting the running processes or looking at the launchd plist file for the executable.  If BlueTool is started manually it will drop the user into an interactive shell as shown in the listing below.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Welcome to BlueTool... Rev 6.0

<span class="gp">bluetool-&gt; </span>?
BlueTool Help
  ?                : Print out all commands and some help.
  autobaud         : Run automatic baud rate on the selected device.
  device           : Select the device to communicate over.
  hci              : Send an HCI <span class="nb">command </span>to the Bluetooth device.
  bcm              : Broadcom specific operations.
  msleep           : Sleep the <span class="nb">caller </span><span class="k">for </span>the given number of milliseconds
  spam             : Spam data to the UART
  <span class="k">if</span>               : <span class="k">if</span> &lt;<span class="nb">test</span>&gt; ? a : b
  <span class="nb">true</span>             : <span class="nb">true
  false</span>            : <span class="nb">false
  echo</span>             : <span class="nb">echo
  </span>power            : Power on/off the Bluetooth device.
  reset            : Reset on/off/pulse the Bluetooth device.
  wake             : Wake on/off/pulse the Bluetooth device.
Give any commands <span class="s1">'-h'</span> <span class="k">for </span>more details.
device returned 3
<span class="gp">bluetool-&gt; </span>device -D
Opening com.apple.uart.bluetooth @ 115200 baud.
<span class="gp">bluetool-&gt; </span></code></pre></figure>

<p>When BlueTool is started by launchd it creates an XPC service called <code class="highlighter-rouge">com.apple.BlueTool</code> and ignores all input from stdin.  Most output is logged to stdout or stderr.</p>

<p>In addition to the interactive shell and XPC service, data is also sent to and received from the Bluetooth hardware.  This communication is carried out over a UART connection and uses the Bluetooth Host-Controller Interface (HCI) command set.</p>

<h2 id="xpc-service">XPC Service</h2>

<p>When BlueTool is started by launchd the undocumented <code class="highlighter-rouge">-R</code> flag causes two things to happen:</p>

<ol>
  <li>BlueTool starts the <code class="highlighter-rouge">com.apple.BlueTool</code> XPC service</li>
  <li>BlueTool ignores all commands passed to it via stdin</li>
</ol>

<p>The XPC service handler first asserts that the message dictionary contains the <code class="highlighter-rouge">kBluetoolMessageId</code> key and then selects a command-specific handler based on its value.  Possible values are 2 through 5 inclusive.  Note that the values 0 and 1 are not bound to any handler, it is unclear to me why.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> kBluetoolMessageId </th>
      <th style="text-align: left"> Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: left"> Undefined.</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left"> Undefined.</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left"> Process given file path as script.</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left"> Process named script.</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left"> Process <code class="highlighter-rouge">\n</code> separated list of commands.  </td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left"> Return version information.</td>
    </tr>
  </tbody>
</table>

<p><br />The following are summaries of each command.</p>

<h3 id="xpc-command-2">XPC Command: 2</h3>

<p>Setting kBluetoolMessageId equal to two causes the program to then look for the <code class="highlighter-rouge">script</code> key.  The value of this key is a string that contains a path to a script to be run by BlueTool.  The script file is simply a single command per line.</p>

<p>During testing I noticed that the file is opened using <code class="highlighter-rouge">fopen()</code> with no checks beforehand to ensure the path is valid.  As a result it is possible to read files at other locations.  Although this is a directory traversal vulnerability there are two caveats:</p>

<ol>
  <li>The sandbox should block reads to unauthorized files</li>
  <li>Data read is sent to stderr</li>
</ol>

<p>Since my testing was on a jailbroken device it is unclear to me if the sandbox had been disabled.  I did find it possible to read <code class="highlighter-rouge">/etc/passwd</code> however this should be tested on a non-jailbroken device.  Regardless, due to the BlueTool process being started by launchd we typically don’t have control or access to stderr.  As a result, this bug is likely not very interesting.</p>

<h3 id="xpc-command-3">XPC Command: 3</h3>

<p>This command allows a client of the XPC service to execute a named script.  The three script names I’ve found so far are: boot, init, and deepsleep.</p>

<h3 id="xpc-command-4">XPC Command: 4</h3>

<p>When kBluetoolMessageId is set to 4 BlueTool will then search for a dictionary key of <code class="highlighter-rouge">command</code>.  The string associated with this key is then split into substrings using <code class="highlighter-rouge">strtok</code> and passed to the central command processor used by both the XPC service and the interactive shell.</p>

<h3 id="xpc-command-5">XPC Command: 5</h3>

<p>The final command simply replies with the chip model, firmware version, and manufacturer as strings. This command takes no inputs.</p>

<h2 id="bluetool-commands">BlueTool Commands</h2>

<p>As was shown previously, BlueTool supports a number of commands.  Most commands accept the <code class="highlighter-rouge">-h</code> flag to show additional information about the command.  Two commands that I looked at in particular are <code class="highlighter-rouge">spam</code> and <code class="highlighter-rouge">bcm</code>.  Before executing most commands it is expected that you connect to a device via the <code class="highlighter-rouge">device</code> command.</p>

<h3 id="spam-segfault">Spam Segfault</h3>

<p>Shortly after I began experimenting with the interactive shell I noticed that executing the <code class="highlighter-rouge">spam</code> command lead to a segfault.  Being hopeful that I may be able to turn this bug into something useful I decided to investigate it.</p>

<p>Connecting to BlueTool with LLDB and passing the <code class="highlighter-rouge">spam</code> command I found that BlueTool was crashing due to trying to branch to the address <code class="highlighter-rouge">0x00000000</code>.  This happened because I was not opening a device beforehand.  Opening a device is required because BlueTool tries to abstract away the hardware to some degree by placing a set of function pointers in memory when opening the device.  These function pointers provide hardware specific functionality.  Since the <code class="highlighter-rouge">spam</code> command does not first ensure a device is open it will blindly try to branch to the address stored in the function pointer.  For more on the function pointers and other data stored when opening a device see the section titled <em>The 0x400 Structure</em>.</p>

<h3 id="downloading-firmware-to-the-bluetooth-module">Downloading Firmware to the Bluetooth Module</h3>

<p>The <code class="highlighter-rouge">bcm</code> command offers a subcommand that allows you to specify the path of a <code class="highlighter-rouge">.hcd</code> file (Broadcom firmware) to download.  I am still in the process of dumping and reversing the firmware, however the presence of this command means it is possible to update the Bluetooth module.</p>

<h2 id="the-0x400-structure">The 0x400 Structure</h2>

<p>Through out the binary there is heavy use of what I’ve dubbed “the 0x400 structure”.  This name came to be because this structure is always referenced by adding 0x400 to a base register.  The structure contains the following.</p>

<table>
  <thead>
    <tr>
      <th> Offset </th>
      <th> Value </th>
      <th> Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> 0x400 </td>
      <td> socket </td>
      <td> UART socket file descriptor</td>
    </tr>
    <tr>
      <td> 0x404 </td>
      <td> open </td>
      <td> boolean value indicating if device is open or closed  </td>
    </tr>
    <tr>
      <td> 0x408 </td>
      <td> 0x19eb1 </td>
      <td> write to socket (1 byte max)</td>
    </tr>
    <tr>
      <td> 0x40c </td>
      <td> 0x19eb9 </td>
      <td> write to socket (R2 bytes max)</td>
    </tr>
    <tr>
      <td> 0x410 </td>
      <td> 0x19ec1 </td>
      <td> call select() on socket.</td>
    </tr>
    <tr>
      <td> 0x414 </td>
      <td> 0x19f41 </td>
      <td> a more different write</td>
    </tr>
    <tr>
      <td> 0x418 </td>
      <td> 0x19fa1 </td>
      <td> read H4 HCI event/cmd/data body/header</td>
    </tr>
    <tr>
      <td> 0x41c </td>
      <td> 0x19e25 </td>
      <td> set baud rate</td>
    </tr>
    <tr>
      <td> 0x420 </td>
      <td> 0x1a175 </td>
      <td> close UART socket</td>
    </tr>
    <tr>
      <td> 0x424 </td>
      <td> 0x1a191 </td>
      <td> flush the socket, input and output</td>
    </tr>
    <tr>
      <td> 0x428 </td>
      <td> 0x1a199 </td>
      <td> spam 0xAA to UART</td>
    </tr>
    <tr>
      <td> 0x42c </td>
      <td> 0x0 </td>
      <td> set via STR at 0x19d84</td>
    </tr>
  </tbody>
</table>

<p><br />The values stored in this structure were obtained by inspecting the memory of a running BlueTool process and mapped to there offset through analysis of the open-device function.</p>

<h2 id="uart-and-hci">UART and HCI</h2>

<p>Communication between BlueTool and the Bluetooth module occurs over a UART connection. The protocol used over this connection is the standard HCI protocol specified by the Bluetooth specification.  BlueTool makes use of various vendor-specific HCI commands.  Since Broadcom does not seem to release datasheets and documentation describing the various commands the following list was compiled based off strings in the binary as well as the Broadcom patchram tool at <a href="https://code.google.com/p/broadcom-bluetooth/">https://code.google.com/p/broadcom-bluetooth/</a>.</p>

<table>
  <thead>
    <tr>
      <th> OpCode </th>
      <th> Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> 0xFC01 </td>
      <td> Write Bluetooth device address</td>
    </tr>
    <tr>
      <td> 0xFC18 </td>
      <td> Update baud rate</td>
    </tr>
    <tr>
      <td> 0xFC1C </td>
      <td> Write SCO PCM int</td>
    </tr>
    <tr>
      <td> 0xFC1E </td>
      <td> Write PCM data format</td>
    </tr>
    <tr>
      <td> 0xFC2E </td>
      <td> Download mini driver</td>
    </tr>
    <tr>
      <td> 0xFC27 </td>
      <td> Write sleep mode</td>
    </tr>
    <tr>
      <td> 0xFC45 </td>
      <td> Write UART clock setting 48 MHz</td>
    </tr>
    <tr>
      <td> 0xFC4C </td>
      <td> Copy bytes to destination address  </td>
    </tr>
    <tr>
      <td> 0xFC4E </td>
      <td> Unknown</td>
    </tr>
    <tr>
      <td> 0xFC6D </td>
      <td> Write i2spcm interface parameter</td>
    </tr>
  </tbody>
</table>

<p><br />The default UART device is opened by calling <code class="highlighter-rouge">socket()</code> and <code class="highlighter-rouge">connect()</code> with the device string <code class="highlighter-rouge">com.apple.uart.Bluetooth</code>.  Other device nodes found are:</p>

<ul>
  <li><code class="highlighter-rouge">/dev/btpoweroff</code></li>
  <li><code class="highlighter-rouge">/dev/btreset</code></li>
  <li><code class="highlighter-rouge">/dev/btwake</code></li>
  <li><code class="highlighter-rouge">/dev/cu.bluetooth</code></li>
  <li><code class="highlighter-rouge">/dev/tty.bluetooth</code></li>
  <li><code class="highlighter-rouge">/dev/uart.bluetooth</code></li>
</ul>

<h2 id="future-work">Future Work</h2>

<p>Moving forward with my analysis of the iOS Bluetooth stack I see the following as interesting next steps:</p>

<ol>
  <li>Analysis of BTServer and BTLEServer</li>
  <li>Reverse engineering of the Broadcom firmware blobs</li>
</ol>

<p>As I have previously mentioned, my goal for this analysis is to document and understand the iOS Bluetooth stack.  Both of these next steps will help further my understanding and I hope will provide a basis for others to work off of.</p>

    </div>
  </div>
</div>

    <footer class="footer">
  <div class="container">
    <div class="row row-footer-space">
      <div class="col-md-4">
        <a href="mailto:info@lightbulbone.com">info@lightbulbone.com</a></li>
      </div>
      <div class="col-md-4">
        
            <a href="https://twitter.com/lightbulbone">
              <i class="fa fa-twitter"></i>
              <span>lightbulbone</span>
            </a>
        
      </div>
      <div class="col-md-4">
        One bright idea after another.

      </div>
    </div>
  </div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/bower_components/bootstrap-sass/assets/javascripts/bootstrap.min.js"></script>

  </body>
</html>
