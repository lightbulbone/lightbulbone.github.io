<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Reversing a macOS Kernel Extension</title>
  <meta name="description" content="In my last post I covered the basics of kernel debugging in macOS.  In this post we will put some of that to use and work through the process of reversing a ..."> 
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="canonical" href="https://www.lightbulbone.com/2016/10/11/dsmos-kext.html">
  <link rel="alternate" type="application/rss+xml" title="LightBulbOne" href="https://www.lightbulbone.com/feed.xml" />
</head>

  <body>
    <nav class="navbar navbar-static-top navbar-inverse" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        <!-- <img src="/img/elastic-path-logo.png" width="10" height="10" /> -->
        LightBulbOne
      </a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a href="/">Blog</a>
            </li>
          
        
      </ul>
    </div>
  </div>
</nav>

    <style>
table{
    /*border-collapse: collapse;*/
    border-spacing: 500px;
    border: 1px solid black;
}

th{
    border: 1px solid black;
}

td{
    border: 1px solid black;
}
</style>


<div class="container">
  <div class="blog-main">
    <div class="blog-post">
      <h2 class="blog-post-title">Reversing a macOS Kernel Extension</h2>
      <p class="blog-post-meta">11 October 2016</p>
      <p>In my <a href="http://lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html">last post</a> I covered the basics of kernel debugging in macOS.  In this post we will put some of that to use and work through the process of reversing a macOS kernel module.</p>

<p>As I said in my last post, in macOS there is a kernel module named “Don’t Steal Mac OS X” (DSMOS) which registers a function with the Mach-O loader to unpack binaries that have the <code class="highlighter-rouge">SG_PROTECTED_VERSION_1</code> flag set on their <code class="highlighter-rouge">__TEXT</code> segment. Finder, Dock, and loginwindow are a few examples of binaries that have this flag set.  My goal for this post is to simply work through the kernel module with the intent of discovering its functionality and use it as an opportunity to learn a bit about kernel debugging.</p>

<p>If you’d like to follow along I pulled the DSMOS module off of a laptop running macOS Sierra Beta (16A286a).  Based on cursory looks at a couple copies from different versions of macOS it hasn’t changed much recently so you should be able to follow along with a copy from Mac OS X 10.11 or macOS Sierra.  As you’ll see in the screenshots, I used IDA Pro for this reversing however using a program like Hopper would be fine as well.</p>

<h2 id="first-look">First Look</h2>

<p>At a glance, the DSMOS kernel module is fairly simple in terms of number of functions.  It has 25 functions of which we only really care about 6.  Most of the functions we don’t care about are constructors or destructors.  Admittedly I haven’t taken the time to understand constructors and destructors used by a kernel module sp will be skipping them in this post.</p>

<p>Typically when I first look at a binary I start by looking at the strings in the binary.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-01.png" width="75%" />
<figcaption>Figure 1: Strings in DSMOS kernel module</figcaption>
</figure>
</center>

<p>As seen in Figure 1, there really aren’t that many strings and they aren’t all that exciting.  The most interesting is probably the string “AppleSMC” which is an indicator that this module interacts with the System Management Controller.</p>

<p>Given that there are so few functions in this binary my approach was to simply go through each of them, have a quick look at the control flow graph (CFG) for a rough estimate of complexity, and put the function either on the “care” or “don’t care” list.  Doing this I ended up with 9 functions of interest (see Table 1).</p>

<table>
  <thead>
    <tr>
      <th>Address</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">00000A9E</code></td>
      <td><code class="highlighter-rouge">sub_A9E</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00000B2A</code></td>
      <td><code class="highlighter-rouge">sub_B2A</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00000D30</code></td>
      <td><code class="highlighter-rouge">sub_D30</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00000E9E</code></td>
      <td><code class="highlighter-rouge">sub_E9E</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">0000125A</code></td>
      <td><code class="highlighter-rouge">sub_125A</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00001616</code></td>
      <td><code class="highlighter-rouge">sub_1616</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00001734</code></td>
      <td><code class="highlighter-rouge">sub_1734</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00001C48</code></td>
      <td><code class="highlighter-rouge">sub_1C48</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">00001C94</code></td>
      <td><code class="highlighter-rouge">sub_1C94</code></td>
    </tr>
  </tbody>
</table>

<p>Table 1: Potentially interesting function addresses and associated names.</p>

<p>With these functions as starting points, the next step is to start working through them.  At this point our goal is identify what each functionality each provides.</p>

<h2 id="registering-an-ioservice-notification-handler">Registering an IOService Notification Handler</h2>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-02.png" width="100%" />
<figcaption>Figure 2: Main block of code in sub_A9E</figcaption>
</figure>
</center>

<p>The relevant block of code from <code class="highlighter-rouge">sub_A9E</code> is shown in Figure 2.  In words, this function first retrieves a matching dictionary for the <code class="highlighter-rouge">AppleSMC</code> service then installs a notification handler that is called when IOKit detects a service with the class name <code class="highlighter-rouge">AppleSMC</code> has been registered.  In the call to <code class="highlighter-rouge">IOService::addNotification()</code> shown in Figure 2 the first argument is the address of the hanlder to be called.  This handler is labelled as <code class="highlighter-rouge">notificationHanlder</code> in Figure 2 and not listed in Table 1 (it was a false negative); its located at address <code class="highlighter-rouge">00000B1A</code> with a default name in IDA of <code class="highlighter-rouge">sub_B1A</code>. <code class="highlighter-rouge">sub_B1A</code> isn’t all that interesting, all it does is wrap <code class="highlighter-rouge">sub_B2A</code> dropping some arguments in the process.</p>

<h2 id="the-notification-handler">The Notification Handler</h2>

<p>When an IOService registers the AppleSMC class the code in <code class="highlighter-rouge">sub_B2A</code> will be notified.  This function begins by calling <code class="highlighter-rouge">OSMetaClassBase::safeMetaCast()</code> to cast the incoming service into an AppleSMC service.  Note that Apple’s documentation states that developers should not call OSMetaClassBase methods directly and should instead use provided macros.  In this case, the call <code class="highlighter-rouge">safeMetaCast()</code> was likely generated by using the <code class="highlighter-rouge">OSDynamicCast</code> macro which Apple lists as a valid macro to be used by developers.</p>

<p>The next block in <code class="highlighter-rouge">sub_B2A</code>, shown in Figure 3, is where things actually start.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-03.png" width="30%" />
<figcaption>Figure 3: Querying SMC for key</figcaption>
</figure>
</center>

<p>Since C++ is horribly annoying to reverse due to all the indirect calls, rather than figuring out what method is represented by <code class="highlighter-rouge">rax+850h</code> I turned to Google.  Searching for <code class="highlighter-rouge">OSK0</code> and <code class="highlighter-rouge">OSK1</code> turns up an <a href="http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/">article</a> posted by Amit Singh.  In it he talks briefly about an older version of the DSMOS kernel extenion and also provides code that uses the <code class="highlighter-rouge">OSK0</code> and <code class="highlighter-rouge">OSK1</code> strings to query the SMC for two keys.  Once these keys have been acquired the kernel extension then computes a SHA-256 hash and compares to a value stored in memory.  If this comparison fails, an error is printed (not shown).</p>

<p>If the hashes match then we skip to the block shown in Figure 4.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-04.png" width="30%" />
<figcaption>Figure 4: Installing DSMOS hook</figcaption>
</figure>
</center>

<p>The first part of this basic block takes the address of <code class="highlighter-rouge">byte_3AA4</code> and our keys returned from the SMC then calls <code class="highlighter-rouge">sub_1616</code>.  If you look at <code class="highlighter-rouge">sub_1616</code> you’ll see it contains a couple loops and a bunch of byte manipulation I didn’t want to reverse.  Looking at where <code class="highlighter-rouge">byte_3AA4</code> is used you’ll see it is used in two places: here in <code class="highlighter-rouge">sub_B2A</code> and in <code class="highlighter-rouge">sub_D30</code>.  Let’s wait a bit to see how it is used before figuring out how it is generated.</p>

<p>After the call to <code class="highlighter-rouge">sub_1616</code> we have two AES decryption keys set.  The first key is the value returned from the SMC when queried with <code class="highlighter-rouge">OSK0</code> and the second key is the value returned when <code class="highlighter-rouge">OSK1</code> is used to query the SMC.  Finally, we see a global variable named <code class="highlighter-rouge">initialized</code> set to 1 and a call to <code class="highlighter-rouge">dsmos_page_transform_hook</code> with the address of <code class="highlighter-rouge">sub_D30</code> as a parameter.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="kt">void</span>
<span class="nf">dsmos_page_transform_hook</span><span class="p">(</span><span class="n">dsmos_page_transform_hook_t</span> <span class="n">hook</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"DSMOS has arrived</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="cm">/* set the hook now - new callers will run with it */</span>
    <span class="n">dsmos_hook</span> <span class="o">=</span> <span class="n">hook</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Listing 1: Source code for <code class="highlighter-rouge">dsmos_page_transform_hook</code> from XNU source</p>

<p>Searching for <code class="highlighter-rouge">dsmos_page_transform_hook</code> in the XNU source we find the code in Listing 1.  This is a pretty simple funciton that simply sets the value of <code class="highlighter-rouge">dsmos_hook</code> to the provided function address.</p>

<h2 id="usage-of-dsmoshook-in-xnu">Usage of <code class="highlighter-rouge">dsmos_hook</code> in XNU</h2>

<p>At this point we will take step briefly away from IDA and kernel extension turning our attention to the XNU source.  For this work I used the source of XNU 3248.60.10 which is the version used by Mac OS X 10.11.6.  If you haven’t done so already, you can download the source from <a href="http://opensource.apple.com/release/os-x-10116/">http://opensource.apple.com/release/os-x-10116/</a>.</p>

<p>As we saw, <code class="highlighter-rouge">dsmos_page_transform_hook</code> simply set the value of <code class="highlighter-rouge">dsmos_hook</code>.  Continuing from here we find that <code class="highlighter-rouge">dsmos_hook</code> is only used in <code class="highlighter-rouge">dsmos_page_transform_hook</code> as we saw and in <code class="highlighter-rouge">dsmos_page_transform</code> (Listing 2).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="kt">int</span>
<span class="nf">dsmos_page_transform</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">src_offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">boolean_t</span> <span class="n">first_wait</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dsmos_hook</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first_wait</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">first_wait</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting for DSMOS...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>   
        <span class="k">return</span> <span class="n">KERN_ABORTED</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">dsmos_hook</span><span class="p">)</span> <span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">src_offset</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Listing 2: Usage of <code class="highlighter-rouge">dsmos_hook</code> by XNU</p>

<p>After ensuring <code class="highlighter-rouge">dsmos_hook</code> the code in LIsting 2 just calls the hook with the parameters passed to <code class="highlighter-rouge">dsmos_page_transform</code>.  This approach allows Apple some flexibility and opens up the opportunity to have multiple hooks in the future. Once again searching the XNU source, we see that the only use of <code class="highlighter-rouge">dsmos_page_transform</code> is in a function called <code class="highlighter-rouge">unprotect_dsmos_segment</code>.  I have not included the source of <code class="highlighter-rouge">unprotect_dsmos_segment</code> since it is a bit longer and also not very exciting.  The most interesting part about it is that it checks to see that the segment is long enough before attempting to call <code class="highlighter-rouge">dsmos_page_transform</code> on it.</p>

<p>Continuing along, <code class="highlighter-rouge">unprotect_dsmos_segment</code> is only called by <code class="highlighter-rouge">load_segment</code>.  <code class="highlighter-rouge">load_segment</code> is a much larger function and is not shown in its entirety but the relevant portion is shown in Listing 3.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SG_PROTECTED_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">unprotect_dsmos_segment</span><span class="p">(</span><span class="n">file_start</span><span class="p">,</span>
                          <span class="n">file_end</span> <span class="o">-</span> <span class="n">file_start</span><span class="p">,</span>
                          <span class="n">vp</span><span class="p">,</span>
                          <span class="n">pager_offset</span><span class="p">,</span>
                          <span class="n">map</span><span class="p">,</span>
                          <span class="n">vm_start</span><span class="p">,</span>
                          <span class="n">vm_end</span> <span class="o">-</span> <span class="n">vm_start</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">LOAD_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Listing 3: Call to <code class="highlighter-rouge">unprotect_dsmos_segment</code> from <code class="highlighter-rouge">load_segment</code></p>

<p>The interesting part of the code in Listing 3 is that <code class="highlighter-rouge">unprotect_dsmos_segment</code> is only called on segments with the <code class="highlighter-rouge">SG_PROTECTED_VERSION_1</code> flag set.  As mentioned earlier, macOS only includes a few binaries with this flag set such as Finder, Dock, and loginwindow.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-05.png" width="80%" />
<figcaption>Figure 5: Main functionality of hook function</figcaption>
</figure>
</center>

<h2 id="the-hook-implementation">The Hook Implementation</h2>

<p>At this point we know that the DSMOS kernel extension queries the SMC for a pair of keys, initializes some AES decryption contexts and global variables, then installs a hook by calling <code class="highlighter-rouge">dsmos_page_transform_hook</code>.  We also know that the Mach-O loader in the kernel will call this hook when it finds a segment with the <code class="highlighter-rouge">SG_PROTECTED_VERSION_1</code> flag set.  The next question then is: what does the hook installed by the DSMOS kernel extension actually do?</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-05.png" width="80%" />
<figcaption>Figure 5: Main functionality of hook function</figcaption>
</figure>
</center>

<p>Prior to the code shown in Figure 5 is the function prologue and setting of a stack cookie; after the code is the checking of the stack cookie and function epilogue.  The code shown starts by checking to see if the initialization flag is set.  This is the same initialization flag we saw being set in <code class="highlighter-rouge">sub_B2A</code> (see Figure 4).  If this flag is not set the function exits, otherwise it enters a series of checks to identify which kernel is calling the hook.  Searching the XNU source you can find the constant <code class="highlighter-rouge">0x2e69cf40</code> in the implementation of <code class="highlighter-rouge">unprotect_dsmos_segment</code> as shown in Listing 4.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>                <span class="k">struct</span> <span class="n">pager_crypt_info</span> <span class="n">crypt_info</span><span class="p">;</span>
                <span class="n">crypt_info</span><span class="p">.</span><span class="n">page_decrypt</span> <span class="o">=</span> <span class="n">dsmos_page_transform</span><span class="p">;</span>
                <span class="n">crypt_info</span><span class="p">.</span><span class="n">crypt_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">crypt_info</span><span class="p">.</span><span class="n">crypt_end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#pragma unused(vp, macho_offset)
</span>                <span class="n">crypt_info</span><span class="p">.</span><span class="n">crypt_ops</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x2e69cf40</span><span class="p">;</span>
                <span class="n">vm_map_offset_t</span> <span class="n">crypto_backing_offset</span><span class="p">;</span>
                <span class="n">crypto_backing_offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* i.e. use map entry's offset */</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Listing 4: XNU setting value of <code class="highlighter-rouge">crypt_info.crypt_ops</code></p>

<p>As Figure 5 shows, there are three basic cases implemented in the hook: no protection, an old kernel, and a new kernel.  The basic block responsible for each case is labelled accordingly.  I did not try to figure out which kernels mapped to which version however if you read <a href="http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/">the article by Amit Singh</a> you’ll notice that he talks about the method where each half of the page is encrypted with one of the SMC keys.  In our kernel extension this corresponds to the <code class="highlighter-rouge">old_kernel</code> basic block.</p>

<p>The method currently in use by Apple starts at the basic block labelled as <code class="highlighter-rouge">new_kernel</code> in Figure 5.  In it we see an 8 byte buffer is zeroed then a call is made to a function I’ve called <code class="highlighter-rouge">unprotect</code> (named <code class="highlighter-rouge">sub_1734</code> by IDA originally).  Looking at the parameters to <code class="highlighter-rouge">unprotect</code> we see it takes the global buffer <code class="highlighter-rouge">byte_3AA4</code> we saw earlier, the source buffer containing the page to be transformed, and the destination buffer to store the transformed page in among other parameters.</p>

<p>This is the point in our reversing where things become very tedious since Apple has moved away from using AES to encrypt the pages to a custom method composed of many byte operations (e.g. shift left/right, logical/exclusive or).</p>

<h2 id="unprotecting-a-protected-page">Unprotecting a Protected Page</h2>

<p>To properly set expectations, due to the tedious nature of this protection mechanism and me being somewhat satisfied with what I’ve learned so far I did not go through the full exercise of reversing Apple’s “unprotect” method.  Originally I had intended to write a program that would be able to apply the transform to a given binary but that program is only partially completed and does not work.  So, with expectations set sufficiently low lets get a feel for the implementation and a couple ways of approaching it.</p>

<p>First lets step back briefly.  Remember we saw the global variable <code class="highlighter-rouge">byte_3AA4</code> being initialized in <code class="highlighter-rouge">sub_B2A</code> and that I had said the code for that was also incredibly tediuous? Well, thanks to the ability to dump memory from the kernel through the debugger we don’t need to reverse it at all.  We just need to connect to a running kernel and ask it politely.</p>

<h3 id="dumping-byte3aa4-from-a-running-kernel">Dumping <code class="highlighter-rouge">byte_3AA4</code> From a Running Kernel</h3>

<p>If you are unclear about how to use the kernel debugger then check out my <a href="http://lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html">previous post</a>.  To get started, on your remote machine start the debugger by hitting the NMI keys (left command, right command, and power together) then connect to the debugger from your local machine.  The following lldb sessions shows the steps all put together.</p>

<figure class="highlight"><pre><code class="language-linenos" data-lang="linenos">(lldb) kdp-remote 192.168.42.101
Version: Darwin Kernel Version 16.0.0: Fri Aug  5 19:25:15 PDT 2016; root:xnu-3789.1.24~6/DEVELOPMENT_X86_64; UUID=4F6F13D1-366B-3A79-AE9C-4
4484E7FAB18; stext=0xffffff802b000000
Kernel UUID: 4F6F13D1-366B-3A79-AE9C-44484E7FAB18
Load Address: 0xffffff802b000000

...

Process 1 stopped
* thread #2: tid = 0x00b8, 0xffffff802b39a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513, name = '0xffffff8
037046ee0', queue = '0x0', stop reason = signal SIGSTOP
    frame #0: 0xffffff802b39a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513 [opt]
(lldb) showallkexts
OverflowError: long too big to convert
UUID                                 kmod_info            address              size                  id  refs TEXT exec            size     
                         version name                          

...

B97F871A-44FD-3EA4-BC46-8FD682118C79 0xffffff7fadf449a0   0xffffff7fadf41000   0x5000               130     0 0xffffff7fadf41000   0x5000   
                           7.0.0 com.apple.Dont_Steal_Mac_OS_X 

...

(lldb) memory read --force --binary --outfile byte_3AA4.bin 0xffffff7fadf44aa4 0xffffff7fadf44aa4+4172 
4172 bytes written to '/Users/dean/Sites/lightbulbone.github.io/byte_3AA4.bin'</code></pre></figure>

<p>We start out by connecting to the remote host using the <code class="highlighter-rouge">kdp-remote</code> command.  Once everything has loaded we can get the address of the DSMOS kernel extension in memory using the <code class="highlighter-rouge">showallkexts</code> command.  In my case the base address is <code class="highlighter-rouge">0xffffff7fadf41000</code>.  We then read the memory at address <code class="highlighter-rouge">0xffffff7fadf44aa4</code> which is the extension base address plus the offset of <code class="highlighter-rouge">0x3aa4</code>; we read 4172 bytes since that is the size of the buffer.</p>

<p>If you were writing a program to unprotect binaries you could use this extracted binary blob rather than trying to reverse the initialization algorithm.</p>

<h3 id="emulating-the-unprotect-algorithm">Emulating the Unprotect Algorithm</h3>

<p>Due to the tedious nature of the algorithm used to “unprotect” a page I decided to try using the <a href="http://www.unicorn-engine.org/">Unicorn Engine</a> to emulate it.  This effort largely failed because it meant I would have to set up memory in Unicorn the same way as it is in the kernel extension and, as I said, the motivation wasn’t quite there.  As far as I know this is possible however it to can be rather tedious; especially in cases where the algorithm isn’t as self-contained as in this case.  Using an IDA plugin such as <a href="https://github.com/cseagle/sk3wldbg">sk3wldbg</a> may help however I was not aware of it at the time.</p>

<h3 id="reversing-the-unprotect-algorithm">Reversing the Unprotect Algorithm</h3>

<p>In the end I just sat down and started working through the algorithm in IDA.  I did begin to write a program to unprotect before my motivation to work through the tedious code fell through the floor.  For me, looking at DSMOS was an opportunity to learn what a kernel module I’ve known about for many years and become more familiar with the macOS kernel.  That being said a few things a worth pointing out.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-06.png" width="65%" />
<figcaption>Figure 6: Loop found in sub_1734</figcaption>
</figure>
</center>

<p>In Figure 6 a portion of <code class="highlighter-rouge">sub_1734</code> is shown.  In it we see the first eight bytes of the <code class="highlighter-rouge">from</code> pointer (stored in <code class="highlighter-rouge">r14</code>) being used to build a value to pass to <code class="highlighter-rouge">sub_125A</code>.</p>

<center>
<figure>
<img src="/assets/images/2016/10/DSMOS-07.png" width="20%" />
<figcaption>Figure 7: Unrolled loop in sub_125A</figcaption>
</figure>
</center>

<p>And, in Figure 7 we see part of <code class="highlighter-rouge">sub_125A</code>.  In this part we see the first two iterations of an unrolled loop.  The point of Figures 6 and 7 is to show some common constructs that come up when reversing code.  If you’re not familiar with these constructs it may help to write some code yourself and then analyze the binary after compilation.</p>

<h2 id="summary">Summary</h2>

<p>The intent of this post was to reverse engineer the DSMOS kernel extension in macOS.  The goal was to understand what functionality the DSMOS extension provided to the kernel and to become more familiar with the XNU kernel.  We also touched on IOKit briefly as well as a possible application of the Unicorn engine.</p>

<p>If you have any questions or comments, please feel to reach out to me on Twitter <a href="https://twitter.com/lightbulbone">@lightbulbone</a>.</p>


    </div>
  </div>
</div>

    <footer class="footer">
  <div class="container">
    <div class="row row-footer-space">
      <div class="col-md-4">
        <a href="mailto:info@lightbulbone.com">info@lightbulbone.com</a></li>
      </div>
      <div class="col-md-4">
        
            <a href="https://twitter.com/lightbulbone">
              <i class="fa fa-twitter"></i>
              <span>lightbulbone</span>
            </a>
        
      </div>
      <div class="col-md-4">
        One bright idea after another.

      </div>
    </div>
  </div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/bower_components/bootstrap-sass/assets/javascripts/bootstrap.min.js"></script>

  </body>
</html>
