<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LightBulbOne</title>
    <description>One bright idea after another.
</description>
    <link>https://www.lightbulbone.com/</link>
    <atom:link href="https://www.lightbulbone.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 27 Dec 2015 09:47:01 -0800</pubDate>
    <lastBuildDate>Sun, 27 Dec 2015 09:47:01 -0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Analysis of the iOS Bluetooth Stack: BlueTool</title>
        <description>&lt;p&gt;On iOS the Bluetooth stack is split into three layers as shown in Figure 1.  At the top is the CoreBluetooth framework used by iOS app developers and at the bottom is the Bluetooth hardware itself.  In between these two layers is a collection of daemons that implement various aspects of the Bluetooth stack.  For example, most Bluetooth Low Energy (BLE) specific functionality is contained in the BTLEServer daemon.  BlueTool is one of the daemons running and is primarily responsible for acting as a bridge between the rest of the Bluetooth stack and the hardware.  It also likely acts as an internal test tool at Apple during development.&lt;/p&gt;

&lt;p&gt;All analysis in this article was carried out on a 5th generation iPod Touch running iOS 8.4 (12H143).  My primary focus during analysis was on understanding what functionality BlueTool provides.  I was not actively looking for bugs despite finding a couple.&lt;/p&gt;

&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px; margin-bottom: 10px&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
         &lt;div class=&quot;col-lg-10 col-lg-offset-1&quot;&gt;
          &lt;figure&gt;
           &lt;img src=&quot;/assets/images/2015/12/iOS-Bluetooth-Overview.png&quot; class=&quot;img-responsive&quot; /&gt;
           &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-lg-8 col-lg-offset-2&quot;&gt;
           &lt;figcaption&gt;Figure 1: Overview of the iOS Bluetooth stack.&lt;/figcaption&gt;
           &lt;/div&gt;&lt;/div&gt;
          &lt;/figure&gt;
         &lt;/div&gt;
        &lt;/div&gt;
       &lt;/div&gt;

&lt;h2 id=&quot;bluetool-io-mechanisms&quot;&gt;BlueTool I/O Mechanisms&lt;/h2&gt;

&lt;p&gt;BlueTool is started automatically at boot by launchd and may also be started manually.  When it is started automatically by launchd, BlueTool is executed with an undocumented &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; flag that can be seen by either inspecting the running processes or looking at the launchd plist file for the executable.  If BlueTool is started manually it will drop the user into an interactive shell as shown in the listing below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Welcome to BlueTool... Rev 6.0

&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;?
BlueTool Help
  ?                : Print out all commands and some help.
  autobaud         : Run automatic baud rate on the selected device.
  device           : Select the device to communicate over.
  hci              : Send an HCI &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;to the Bluetooth device.
  bcm              : Broadcom specific operations.
  msleep           : Sleep the &lt;span class=&quot;nb&quot;&gt;caller &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the given number of milliseconds
  spam             : Spam data to the UART
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;               : &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &amp;lt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&amp;gt; ? a : b
  &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;             : &lt;span class=&quot;nb&quot;&gt;true
  false&lt;/span&gt;            : &lt;span class=&quot;nb&quot;&gt;false
  echo&lt;/span&gt;             : &lt;span class=&quot;nb&quot;&gt;echo
  &lt;/span&gt;power            : Power on/off the Bluetooth device.
  reset            : Reset on/off/pulse the Bluetooth device.
  wake             : Wake on/off/pulse the Bluetooth device.
Give any commands &lt;span class=&quot;s1&quot;&gt;&#39;-h&#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more details.
device returned 3
&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;device -D
Opening com.apple.uart.bluetooth @ 115200 baud.
&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When BlueTool is started by launchd it creates an XPC service called &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.BlueTool&lt;/code&gt; and ignores all input from stdin.  Most output is logged to stdout or stderr.&lt;/p&gt;

&lt;div class=&quot;panel panel-info&quot;&gt;
           &lt;div class=&quot;panel-heading&quot;&gt;
             &lt;h3 class=&quot;panel-title&quot;&gt;Side Note&lt;/h3&gt;
           &lt;/div&gt;
           &lt;div class=&quot;panel-body&quot;&gt;
            
You can modify a launchd plist to include the &quot;StandardOutPath&quot; and &quot;StandardErrorPath&quot; keys to redirect each to a file.  Note that on iOS you also need to keep in mind which rules are enforced by the sandbox. Not all paths the user may access on the filesystem are valid.

           &lt;/div&gt;
         &lt;/div&gt;

&lt;p&gt;In addition to the interactive shell and XPC service, data is also sent to and received from the Bluetooth hardware.  This communication is carried out over a UART connection and uses the Bluetooth Host-Controller Interface (HCI) command set.&lt;/p&gt;

&lt;h2 id=&quot;xpc-service&quot;&gt;XPC Service&lt;/h2&gt;

&lt;p&gt;When BlueTool is started by launchd the undocumented &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; flag causes two things to happen:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BlueTool starts the &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.BlueTool&lt;/code&gt; XPC service&lt;/li&gt;
  &lt;li&gt;BlueTool ignores all commands passed to it via stdin&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The XPC service handler first asserts that the message dictionary contains the &lt;code class=&quot;highlighter-rouge&quot;&gt;kBluetoolMessageId&lt;/code&gt; key and then selects a command-specific handler based on its value.  Possible values are 2 through 5 inclusive.  Note that the values 0 and 1 are not bound to any handler, it is unclear to me why.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; kBluetoolMessageId &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; Description &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Undefined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Undefined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process given file path as script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process named script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; separated list of commands.  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Return version information.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The following are summaries of each command.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-2&quot;&gt;XPC Command: 2&lt;/h3&gt;

&lt;p&gt;Setting kBluetoolMessageId equal to two causes the program to then look for the &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; key.  The value of this key is a string that contains a path to a script to be run by BlueTool.  The script file is simply a single command per line.&lt;/p&gt;

&lt;p&gt;During testing I noticed that the file is opened using &lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt; with no checks beforehand to ensure the path is valid.  As a result it is possible to read files at other locations.  Although this is a directory traversal vulnerability there are two caveats:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The sandbox should block reads to unauthorized files&lt;/li&gt;
  &lt;li&gt;Data read is sent to stderr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since my testing was on a jailbroken device it is unclear to me if the sandbox had been disabled.  I did find it possible to read &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt; however this should be tested on a non-jailbroken device.  Regardless, due to the BlueTool process being started by launchd we typically don’t have control or access to stderr.  As a result, this bug is likely not very interesting.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-3&quot;&gt;XPC Command: 3&lt;/h3&gt;

&lt;p&gt;This command allows a client of the XPC service to execute a named script.  The three script names I’ve found so far are: boot, init, and deepsleep.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-4&quot;&gt;XPC Command: 4&lt;/h3&gt;

&lt;p&gt;When kBluetoolMessageId is set to 4 BlueTool will then search for a dictionary key of &lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;.  The string associated with this key is then split into substrings using &lt;code class=&quot;highlighter-rouge&quot;&gt;strtok&lt;/code&gt; and passed to the central command processor used by both the XPC service and the interactive shell.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-5&quot;&gt;XPC Command: 5&lt;/h3&gt;

&lt;p&gt;The final command simply replies with the chip model, firmware version, and manufacturer as strings. This command takes no inputs.&lt;/p&gt;

&lt;h2 id=&quot;bluetool-commands&quot;&gt;BlueTool Commands&lt;/h2&gt;

&lt;p&gt;As was shown previously, BlueTool supports a number of commands.  Most commands accept the &lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; flag to show additional information about the command.  Two commands that I looked at in particular are &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm&lt;/code&gt;.  Before executing most commands it is expected that you connect to a device via the &lt;code class=&quot;highlighter-rouge&quot;&gt;device&lt;/code&gt; command.&lt;/p&gt;

&lt;h3 id=&quot;spam-segfault&quot;&gt;Spam Segfault&lt;/h3&gt;

&lt;p&gt;Shortly after I began experimenting with the interactive shell I noticed that executing the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command lead to a segfault.  Being hopeful that I may be able to turn this bug into something useful I decided to investigate it.&lt;/p&gt;

&lt;p&gt;Connecting to BlueTool with LLDB and passing the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command I found that BlueTool was crashing due to trying to branch to the address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt;.  This happened because I was not opening a device beforehand.  Opening a device is required because BlueTool tries to abstract away the hardware to some degree by placing a set of function pointers in memory when opening the device.  These function pointers provide hardware specific functionality.  Since the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command does not first ensure a device is open it will blindly try to branch to the address stored in the function pointer.  For more on the function pointers and other data stored when opening a device see the section titled &lt;em&gt;The 0x400 Structure&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;downloading-firmware-to-the-bluetooth-module&quot;&gt;Downloading Firmware to the Bluetooth Module&lt;/h3&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm&lt;/code&gt; command offers a subcommand that allows you to specify the path of a &lt;code class=&quot;highlighter-rouge&quot;&gt;.hcd&lt;/code&gt; file (Broadcom firmware) to download.  I am still in the process of dumping and reversing the firmware, however the presence of this command means it is possible to update the Bluetooth module.&lt;/p&gt;

&lt;h2 id=&quot;the-0x400-structure&quot;&gt;The 0x400 Structure&lt;/h2&gt;

&lt;p&gt;Through out the binary there is heavy use of what I’ve dubbed “the 0x400 structure”.  This name came to be because this structure is always referenced by adding 0x400 to a base register.  The structure contains the following.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; Offset &lt;/th&gt;
      &lt;th&gt; Value &lt;/th&gt;
      &lt;th&gt; Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x400 &lt;/td&gt;
      &lt;td&gt; socket &lt;/td&gt;
      &lt;td&gt; UART socket file descriptor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x404 &lt;/td&gt;
      &lt;td&gt; open &lt;/td&gt;
      &lt;td&gt; boolean value indicating if device is open or closed  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x408 &lt;/td&gt;
      &lt;td&gt; 0x19eb1 &lt;/td&gt;
      &lt;td&gt; write to socket (1 byte max)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x40c &lt;/td&gt;
      &lt;td&gt; 0x19eb9 &lt;/td&gt;
      &lt;td&gt; write to socket (R2 bytes max)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x410 &lt;/td&gt;
      &lt;td&gt; 0x19ec1 &lt;/td&gt;
      &lt;td&gt; call select() on socket.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x414 &lt;/td&gt;
      &lt;td&gt; 0x19f41 &lt;/td&gt;
      &lt;td&gt; a more different write&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x418 &lt;/td&gt;
      &lt;td&gt; 0x19fa1 &lt;/td&gt;
      &lt;td&gt; read H4 HCI event/cmd/data body/header&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x41c &lt;/td&gt;
      &lt;td&gt; 0x19e25 &lt;/td&gt;
      &lt;td&gt; set baud rate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x420 &lt;/td&gt;
      &lt;td&gt; 0x1a175 &lt;/td&gt;
      &lt;td&gt; close UART socket&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x424 &lt;/td&gt;
      &lt;td&gt; 0x1a191 &lt;/td&gt;
      &lt;td&gt; flush the socket, input and output&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x428 &lt;/td&gt;
      &lt;td&gt; 0x1a199 &lt;/td&gt;
      &lt;td&gt; spam 0xAA to UART&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x42c &lt;/td&gt;
      &lt;td&gt; 0x0 &lt;/td&gt;
      &lt;td&gt; set via STR at 0x19d84&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The values stored in this structure were obtained by inspecting the memory of a running BlueTool process and mapped to there offset through analysis of the open-device function.&lt;/p&gt;

&lt;h2 id=&quot;uart-and-hci&quot;&gt;UART and HCI&lt;/h2&gt;

&lt;p&gt;Communication between BlueTool and the Bluetooth module occurs over a UART connection. The protocol used over this connection is the standard HCI protocol specified by the Bluetooth specification.  BlueTool makes use of various vendor-specific HCI commands.  Since Broadcom does not seem to release datasheets and documentation describing the various commands the following list was compiled based off strings in the binary as well as the Broadcom patchram tool at &lt;a href=&quot;https://code.google.com/p/broadcom-bluetooth/&quot;&gt;https://code.google.com/p/broadcom-bluetooth/&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; OpCode &lt;/th&gt;
      &lt;th&gt; Description &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC01 &lt;/td&gt;
      &lt;td&gt; Write Bluetooth device address&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC18 &lt;/td&gt;
      &lt;td&gt; Update baud rate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC1C &lt;/td&gt;
      &lt;td&gt; Write SCO PCM int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC1E &lt;/td&gt;
      &lt;td&gt; Write PCM data format&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC2E &lt;/td&gt;
      &lt;td&gt; Download mini driver&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC27 &lt;/td&gt;
      &lt;td&gt; Write sleep mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC45 &lt;/td&gt;
      &lt;td&gt; Write UART clock setting 48 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC4C &lt;/td&gt;
      &lt;td&gt; Copy bytes to destination address  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC4E &lt;/td&gt;
      &lt;td&gt; Unknown&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC6D &lt;/td&gt;
      &lt;td&gt; Write i2spcm interface parameter&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The default UART device is opened by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;socket()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;connect()&lt;/code&gt; with the device string &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.uart.Bluetooth&lt;/code&gt;.  Other device nodes found are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btpoweroff&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btreset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btwake&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/cu.bluetooth&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/tty.bluetooth&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/uart.bluetooth&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future Work&lt;/h2&gt;

&lt;p&gt;Moving forward with my analysis of the iOS Bluetooth stack I see the following as interesting next steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Analysis of BTServer and BTLEServer&lt;/li&gt;
  &lt;li&gt;Reverse engineering of the Broadcom firmware blobs&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As I have previously mentioned, my goal for this analysis is to document and understand the iOS Bluetooth stack.  Both of these next steps will help further my understanding and I hope will provide a basis for others to work off of.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Dec 2015 01:15:09 -0800</pubDate>
        <link>https://www.lightbulbone.com/2015/12/27/bluetool.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2015/12/27/bluetool.html</guid>
        
        
      </item>
    
      <item>
        <title>From Zero To SDR</title>
        <description>&lt;p&gt;&lt;strong&gt;Heads Up: This post is not complete. While updating the blog platform it snuck out.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Software Defined Radio, usually referred to as SDR, is something that has fascinated me for a couple years but was always out of reach due to available time and resources.  With devices on the market now like the AirSpy, HackRF, B200/B210, BladeRF, and RTL-SDR the barrier to entry has come down significantly in the last couple years.  Since my knowledge of SDR and radio in general was pretty much nothing I thought I’d start with a $20 &lt;a href=&quot;http://hakshop.myshopify.com/collections/software-defined-radio/products/software-defined-radio-kit-rtl-sdr?variant=424034573&quot;&gt;RTL-SDR from Hak5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Not really knowing where to start after plugging the RTL-SDR in for the first time I took a look at the &lt;a href=&quot;http://greatscottgadgets.com/sdr/&quot;&gt;Software Defined Radio with HackRF&lt;/a&gt; lessons created by Michael Ossman.  The lessons are actually quite good, they provide a great introduction to GNU Radio and some of the fundamentals of radio.&lt;/p&gt;

&lt;p&gt;I also tried reading books.  I picked up &lt;a href=&quot;http://www.amazon.ca/Understanding-Digital-Signal-Processing-Edition/dp/0137027419&quot;&gt;Understanding Digial Signal Processing&lt;/a&gt; by Richard Lyons thinking that knowing a bit about DSP would be useful.  Pro tip: reading a DSP textbook is extremely dry.  Even for someone who has a strong background in mathematics.  What I wanted to just the practical side of it for now thinking that as I got more into radio and DSP I’d learn the background.&lt;/p&gt;

&lt;p&gt;It was around this time, frustrated that most resources I was finding focused on the mathematics, I found an application called &lt;a href=&quot;http://gqrx.dk&quot;&gt;GQRX&lt;/a&gt;. GQRX is great. It lets you explore the radio spectrum using whatever SDR you’ve got connected to your computer.  It is built on top of GNU Radio so it has excellent support for hardware and it also provides several demodulators.  Personally, I found exploring the spectrum to be the most fun way to get into things.  At first it was a fun way to look for FM signals that I can listen too. Doing this I found several local taxi services, the public transit systems, and a few hotels.  I also found a bunch of signals that were clearly not FM and my curiousity kicked into fully swing.&lt;/p&gt;

&lt;p&gt;Staring at interesting looking (“pretty”) signals didn’t really pan out very well.  I knew nothing about the device producing the signal, I knew nothing about modulation and carrier signals, and, on top of all that, I didn’t know the tools.  At the time pretty much all the buttons in GQRX and blocks in GNU Radio were pretty much foreign. If I wanted to get anywhere, all of this needed to change.&lt;/p&gt;

&lt;h3 id=&quot;picking-a-device&quot;&gt;Picking a Device&lt;/h3&gt;

&lt;p&gt;The easiest unknown to solve was know the device that produced a signal.  My solution to this was pretty straight forward: buy something.  After a bit of poking around, I settled on the BIOS 315BC (Figure 1) from a local drug store.  It was cheap, advertised wireless functionality, and I was able to find the FCC filings for it. A bonus is that the device has a button on the back of the remote sensor alloBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBwing you to force a transmission.&lt;/p&gt;

&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px; margin-bottom: 10px&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
         &lt;div class=&quot;col-lg-10 col-lg-offset-1&quot;&gt;
          &lt;figure&gt;
           &lt;img src=&quot;/assets/images/2015/07/LDBIOS315BC.jpg&quot; class=&quot;img-responsive&quot; /&gt;
           &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-lg-8 col-lg-offset-2&quot;&gt;
           &lt;figcaption&gt;Figure 1: BIOS 315BC wireless thermometer.&lt;/figcaption&gt;
           &lt;/div&gt;&lt;/div&gt;
          &lt;/figure&gt;
         &lt;/div&gt;
        &lt;/div&gt;
       &lt;/div&gt;

&lt;p&gt;Once I had the device, the first step was to figure out what frequency it transmits on.  The packaging didn’t seem to reveal any clues so I looked up the FCC filings. At the time, the extent of my FCC ID searching was limited to &lt;a href=&quot;https://fccid.io/&quot;&gt;https://fccid.io/&lt;/a&gt; which yielded a result claiming the device operates on 433.92 MHz.  I should note that I never did find the FCC ID on the device itself, I just Googled for it and came up with XK3315TX.  Part of me suspects that FCC ID is from a slightly different model because there was no mention of it being capable of operating on three channels and when I actually started looking I found the device transmitted on 433.96 MHz. Regardless, we have a starting frequency to investigate in GQRX.&lt;/p&gt;

&lt;div class=&quot;panel panel-info&quot;&gt;
           &lt;div class=&quot;panel-heading&quot;&gt;
             &lt;h3 class=&quot;panel-title&quot;&gt;Side Note&lt;/h3&gt;
           &lt;/div&gt;
           &lt;div class=&quot;panel-body&quot;&gt;
            
This device operates in what is known as an &lt;i&gt;ISM Band&lt;/i&gt;.  The ISM Band is a set of frequencies that are unlicensed for use in industrial, scientific, and medical applications.  There are 12 such bands defined by the ITU-R with another common one being the 2.4 GHz band where microwave ovens, cordless phones, Bluetooth, and WiFI operate.

           &lt;/div&gt;
         &lt;/div&gt;

&lt;h3 id=&quot;first-steps-with-gqrx&quot;&gt;First Steps With GQRX&lt;/h3&gt;

&lt;p&gt;With the frequency from the FCC report it is time to have a look at the surrounding spectrum in GQRX.  As I said earlier, GQRX is a great tool for viewing the radio spectrum.  The primary display consists of an &lt;em&gt;FFT plot&lt;/em&gt; on top and a &lt;em&gt;waterfall plot&lt;/em&gt; at the bottom. The FFT—Fast Fourier Transform—plot shows the power level instantaneously at each frequency while the waterfall plot shows the same information over time.  On the side of GQRX is a variety of configuration parameters.  For this initial investigation I left them all at the defaults.&lt;/p&gt;

&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px; margin-bottom: 10px&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
         &lt;div class=&quot;col-lg-10 col-lg-offset-1&quot;&gt;
          &lt;figure&gt;
           &lt;img src=&quot;/assets/images/2015/07/GQRX43396FM.jpg&quot; class=&quot;img-responsive&quot; /&gt;
           &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-lg-8 col-lg-offset-2&quot;&gt;
           &lt;figcaption&gt;Figure 2: Initial capture of transmission in GQRX.&lt;/figcaption&gt;
           &lt;/div&gt;&lt;/div&gt;
          &lt;/figure&gt;
         &lt;/div&gt;
        &lt;/div&gt;
       &lt;/div&gt;

&lt;p&gt;Figure 2 shows a screen shot of GQRX that was taken during a transmission from the remote temperature sensor. The first thing to note is that I have actually tuned to 433.96 MHz instead of 433.92 Mhz.  I did this because at the time I took the screen shot I already knew the original 433.92 MHz is incorrect; perhaps it is due to the channel switch on the back of the remote sensor. When I first saw this result on the FFT I was pretty excited, it works! It’s sending the temperature! But… how?  Knowing nothing about radio transmisssions other than if I tune my radio to 91.3 I get to hear different music than if it’s set to 103.5, it was time to start learning.&lt;/p&gt;

&lt;h3 id=&quot;a-brief-detour-into-digital-modulation&quot;&gt;A Brief Detour Into Digital Modulation&lt;/h3&gt;

&lt;p&gt;We’re now at the point where we need to start thinking about how the temperature is transmitted over a radio signal to the base station.  To do accomplish this task the remote sensor must encode the temperature data in the signal such that it can be recovered again by the base station; for this we must &lt;em&gt;modulate&lt;/em&gt; the &lt;em&gt;carrier wave&lt;/em&gt;.  The carrier wave is simply a radio wave emitted at a sufficiently high frequency such that the encoded data can be retrieved while modulation is the technique used to encode the data in the carrier wave.&lt;/p&gt;

&lt;p&gt;With respect to digital modulation there are three broad categories: amplitude shift keying (ASK), frequency shift keying (FSK), and phase shift keying (PSK).  The notion of “keying” is just that the data is transmitted in one of a finite number of symbols.  Rather than delving into each of ASK, FSK, and PSK here I highly recommend reading through the Wikipedia articles.&lt;/p&gt;

&lt;h3 id=&quot;identifying-the-modulation-type&quot;&gt;Identifying the Modulation Type&lt;/h3&gt;

&lt;p&gt;So the question we really want to answer now is this: how is this signal modulated?&lt;/p&gt;

&lt;p&gt;My first guess was that it was something known as BPSK, binary phase shift keying. Some reading had lead me to believe that BPSK is a pretty common type of modulation and that it can be used to efficiently transmit binary data.  However, the more I looked at the FFT and waterfall plot the less I was convinced (check out the &lt;a href=&quot;http://www.sigidwiki.com/wiki/Signal_Identification_Guide&quot;&gt;Signal Identifcation Wiki&lt;/a&gt; for many examples).  Another thing that came up was the difficulty in demodulating a BPSK signal, it turns out that receiving a BPSK signal is somewhat difficult and is just not something you’d find on a cheap mass-production thermometer.  A similar thought exercise lead to me ruling out various forms of FSK modulation as well.&lt;/p&gt;

&lt;p&gt;So this leaves us with ASK.  One of the simplest types of ASK modulation is &lt;em&gt;On-Off Keying (OOK)&lt;/em&gt;.  This simply means that the presence of a signal indicates a binary 1 and the absence of a signal indicates a binary 0.  The duration of each on or off segment is then used to indicate the number of consecutive 1’s or 0’s in the binary stream.  This all seemed plausible, except that looking at the FFT or waterfall didn’t seem to be all that useful at this point.&lt;/p&gt;

&lt;h3 id=&quot;moving-beyond-gqrx&quot;&gt;Moving Beyond GQRX&lt;/h3&gt;

&lt;p&gt;Admittedly I was stuck at this point for a little while.  I didn’t recognize the patterns I was seeing in the waterfall plot and the FFT, while pretty looking, wasn’t giving me any other clues.  It wasn’t until I read &lt;a href=&quot;http://blog.atx.name/reverse-engineering-radio-weather-station/&quot;&gt;this post&lt;/a&gt; that appeared on http://rtl-sdr.com that I managed move forward.  The key was to simply record an audio sample of the transmission and work from there to identify the bits and encoding.  To do this I simply used the record feature of GQRX and set the demodulation to AM thinking that the data has likely been through some kind of an ASK modulator.&lt;/p&gt;

&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px; margin-bottom: 10px&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
         &lt;div class=&quot;col-lg-10 col-lg-offset-1&quot;&gt;
          &lt;figure&gt;
           &lt;img src=&quot;/assets/images/2015/07/DirtyAudioWaveform.jpg&quot; class=&quot;img-responsive&quot; /&gt;
           &lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-lg-8 col-lg-offset-2&quot;&gt;
           &lt;figcaption&gt;Figure 3: Audio waveform from GQRX recording without any processing.&lt;/figcaption&gt;
           &lt;/div&gt;&lt;/div&gt;
          &lt;/figure&gt;
         &lt;/div&gt;
        &lt;/div&gt;
       &lt;/div&gt;

&lt;p&gt;Figure 3 shows the waveform of the audio captured using GQRX.  As we can see, on the immediate left we have some noisy looking data and on the far right we have what looks like gradually increasing noise.  The center portion looks very structured and could possibly be data.  When listening to the sample you will indded hear this noise-structured-noise pattern.  A quick visual inspection shows us that there seems to be three durations of silence during packets: short, medium, and long.  Looking more it’s probably a safe guess the long period of silence is a delimiter of some kind but the short and medium periods are a bit of a mystery.  What we do know though is that this is not On-Off Keying since we don’t see the expected presence-of-the-carrier-absence-of-the-carrier pattern; instead we see periods of silence delimited by a very short spikes.&lt;/p&gt;

&lt;p&gt;After staring at the waveform for awhile I decided that the short periods of silence represent a binary &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, the medium periods represent a binary &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, and the long periods represent a delimiter between repeated packets where each packet is five bytes.&lt;/p&gt;

&lt;h3 id=&quot;processing-the-waveform&quot;&gt;Processing The Waveform&lt;/h3&gt;

&lt;p&gt;At this point I could either (a) test this theory by translating everythign manually or (b) process the data and translate it with a script.  Option (b) seemed like the winner since I wanted to translate a bunch of different captured packets to help with identifying the packet structure.  This meant I neeed a script that did — things: :q&lt;/p&gt;

</description>
        <pubDate>Sun, 19 Jul 2015 05:55:46 -0700</pubDate>
        <link>https://www.lightbulbone.com/2015/07/19/from-zero-to-sdr.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2015/07/19/from-zero-to-sdr.html</guid>
        
        
      </item>
    
      <item>
        <title>Wargames and CTFs</title>
        <description>&lt;p&gt;One great way to practice your skills in the pentesting world is to participate in wargames and CTFs.  You can play wargames on sites like &lt;a href=&quot;http://overthewire.org/wargames/&quot;&gt;OverTheWire&lt;/a&gt; or &lt;a href=&quot;http://www.smashthestack.org/&quot;&gt;SmashTheStack&lt;/a&gt;, take part in sanctioned CTFs such as those through &lt;a href=&quot;http://ctf365.com/&quot;&gt;CTF365&lt;/a&gt;, or setup your own lab at home and play around in it.&lt;/p&gt;

&lt;p&gt;This afternoon I thought it’d be fun to play a quick wargame and decided there might be some educational benefit to others by sharing my notes.  The game I chose was &lt;code class=&quot;highlighter-rouge&quot;&gt;Leviathan&lt;/code&gt; on OverTheWire, it’s fairly easy but a good starting point for those new to this and a fun hour or so for those not so new.&lt;/p&gt;

&lt;p&gt;Check out my notes on my &lt;a href=&quot;https://github.com/lightbulbone/wargames&quot;&gt;GitHub repository&lt;/a&gt;.  Feel free to message me if you have any questions!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Aug 2014 09:57:41 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/08/12/wargames-and-ctfs.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/08/12/wargames-and-ctfs.html</guid>
        
        
      </item>
    
      <item>
        <title>IDA Processor Options - Oops.</title>
        <description>&lt;p&gt;So I’ve been working through the LLB code that I talked about in my last article and kept running into incorrectly decoded instructions.  I knew they were wrong because (A) the output IDA was giving made no sense and (B) I manually decoded some of them myself to check it.&lt;/p&gt;

&lt;p&gt;The problem? I forgot to set the processor options when loading the LLB binary.&lt;/p&gt;

&lt;p&gt;So, take my mistake as a learning experience.  When loading your binary, be sure to set your processor type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2014/Jul/Load_IDA-phg.png&quot; alt=&quot;IDA Pro Load File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And then, the important part, set the processor options.  In this case the default architecture selected by the ARM processor module was not inline with the architecture used by the LLB code.  For LLB, be sure to select &lt;strong&gt;ARMv7-AR&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2014/Jul/ARM_Options.png&quot; alt=&quot;ARM Processor Options&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Live and learn,&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Jul 2014 08:58:33 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/07/21/ida-processor-options-oops.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/07/21/ida-processor-options-oops.html</guid>
        
        
      </item>
    
      <item>
        <title>Reverse Engineering The iOS Boot Mechanism (Part 1)</title>
        <description>&lt;p&gt;Due to some unforeseen medical issues, my time as an elite athlete adbruptly came to an end a couple months ago and while dealing with those issues I had a lot of free time on my hands.  So, naturally I finally got around to reading &lt;a href=&quot;http://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542&quot;&gt;Mac OS X Internals: A Systems Approach&lt;/a&gt; by Amit Singh and &lt;a href=&quot;http://www.amazon.com/Mac-OS-iOS-Internals-Apples/dp/1118057651&quot;&gt;Mac OS X and iOS Internals: To the Apple’s Core&lt;/a&gt; by Johnathan Levin in their entirety.  Both are excellent books and highly recommended.  Between reading those books, my general curiousity in low-level computer concepts, and an even greater curiousity in mobile computing I decided it was time to take a crack at reverse engineering the iOS boot mechnisms.&lt;/p&gt;

&lt;h3 id=&quot;components-of-the-boot-mechanism&quot;&gt;Components of the Boot Mechanism&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/Components.png&quot; alt=&quot;iOS Boot Components&quot; title=&quot;iOS Boot Components&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before diving into setting up for decrypting and dissasembling the various components let’s first take a quick look at an overview of the boot sequence.&lt;/p&gt;

&lt;p&gt;It all starts in the &lt;em&gt;Boot ROM&lt;/em&gt;.  This bit of code is flashed onto the device during chip fabrication and can’t be updated.  It contains the Apple Root CA certificate and is responsible for checking the integrity of the second stage bootloader, &lt;em&gt;Low-Level Bootloader (LLB)&lt;/em&gt;.  The Boot ROM performs some initialization tasks and will either proceed to load LLB or move towards DFU mode through &lt;em&gt;iBSS&lt;/em&gt; and &lt;em&gt;iBEC&lt;/em&gt;.  LLB and the third stage bootloader, &lt;em&gt;iBoot&lt;/em&gt;, are tasked with the job of initializing the remaining hardware components and eventually loading the kernel.  Both LLB and iBoot are stored on the filesystem meaning that they can be updated through an iOS upgrade.  We’ll see more of the specifics in future blog posts as I work through the various components.&lt;/p&gt;

&lt;h3 id=&quot;getting-the-pieces&quot;&gt;Getting The Pieces&lt;/h3&gt;

&lt;p&gt;Before we can begin, we need to gather a few pieces and establish a consistent work environment.  To follow along you will need:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mac OS X &amp;gt;= 10.8 (Mountain Lion)&lt;/li&gt;
  &lt;li&gt;iOS 7.0.4 IPSW (iOS: 7.0.4, Build: 11B554a, Device: iPhone3,1)&lt;/li&gt;
  &lt;li&gt;img3decrypt.rb&lt;/li&gt;
  &lt;li&gt;IDA Pro&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In theory you can use any version of iOS, the reason for iOS 7.0.4 is that I have an iPhone 4 running that and eventually plan on translating some of this reversing into fun tricks on the device.  If you don’t have a license for IDA Pro then you can accomplish everything using the &lt;a href=&quot;http://hopperapp.com/&quot;&gt;Hopper Disassember&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find links to all recently released iOS images along with the corresping key/IV pairs on the fabulous &lt;a href=&quot;http://www.icj.me/&quot;&gt;http://www.icj.me/&lt;/a&gt;.  The image and key/IV pairs we’re interested in can be found at &lt;a href=&quot;http://www.icj.me/ios/keys/iPhone3,1/11B554a&quot;&gt;http://www.icj.me/ios/keys/iPhone3,1/11B554a&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next piece you’ll want to grab is the &lt;a href=&quot;https://github.com/pod2g/ios_stuff/blob/master/misc-hs07/img3decrypt.rb&quot;&gt;img3decrypt.rb&lt;/a&gt; script created by pod2g.  To use img3decrypt.rb you’ll also need Ruby installed.&lt;/p&gt;

&lt;h3 id=&quot;unpacking-the-ipsw&quot;&gt;Unpacking the IPSW&lt;/h3&gt;

&lt;p&gt;Before we unpack the IPSW it’s important to keep your workspace organized.  I like to use a folder structure such as the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Reversing/iOS/7.0.4/iPhone3,1/decrypted/
~/Reversing/iOS/7.0.4/iPhone3,1/ipsw/
~/Reversing/iOS/7.0.4/iPhone3,1/unpacked/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next up, we need to unpack the iOS image (IPSW).  This is pretty easy since an &lt;code class=&quot;highlighter-rouge&quot;&gt;.ipsw&lt;/code&gt; is actually just a ZIP-file in disguise.  Go ahead and tack a &lt;code class=&quot;highlighter-rouge&quot;&gt;.zip&lt;/code&gt; onto the image name and then unzip it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy iPhone3,1]$ cd ipsw/
[dean@zippy ipsw]$ mv iPhone3,1_7.0.4_11B554a_Restore.ipsw iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip
[dean@zippy ipsw]$ unzip iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip -d ../unpacked/
Archive:  iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip
  inflating: ../unpacked/058-1056-002.dmg  
  inflating: ../unpacked/058-1086-002.dmg  
  inflating: ../unpacked/058-1139-002.dmg  

  ... snip ...

   creating: ../unpacked/Firmware/usr/
   creating: ../unpacked/Firmware/usr/local/
   creating: ../unpacked/Firmware/usr/local/standalone/
  inflating: ../unpacked/kernelcache.release.n90  
  inflating: ../unpacked/Restore.plist  
[dean@zippy ipsw]$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point you should have an unpacked copy of the iOS image in your &lt;code class=&quot;highlighter-rouge&quot;&gt;unpacked&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&quot;decrypting-llb&quot;&gt;Decrypting LLB&lt;/h3&gt;

&lt;p&gt;Once we’ve unpacked the iOS image the next thing we need to do is decrypt the LLB binary.  Like most files in the iOS image, the LLB binary is contained inside an IMG3 file with the data section encrypted using a key that the iOS device derives during the upgrade process.  Therefore, in order to get at the data we first need the key and associated initialization vector (IV) for the LLB binary.  Note that the key/IV pair is different for each file in the iOS image as well as for each device and build version combination.&lt;/p&gt;

&lt;p&gt;Now, let’s get started.  The first thing we’ll want to do is grab the key and IV from &lt;a href=&quot;http://www.icj.me/ios/keys/iPhone3,1/11B554a&quot;&gt;http://www.icj.me/ios/keys/iPhone3,1/11B554a&lt;/a&gt;.  I’ve also copied the key/IV pair below to simplify things.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Key: e3b72ddcdc89edf6f29258c7a0e65cba0d808d1a965892515bfff988e3fd5906
IV:  3eb5aa8acbe1386dc13e2673a2546128
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Once we have that, open up your terminal and move to the directory where the LLB binary is.  Once you’re there, just run img3decrypt.rb and it should report that the decryption succeeded and it created a &lt;code class=&quot;highlighter-rouge&quot;&gt;.dec&lt;/code&gt; file.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;.dec&lt;/code&gt; contains the decrypted version of LLB.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy ~]$ cd ~/Reversing/iOS/7.0.4/iPhone3,1/unpacked/Firmware/all_flash/all_flash.n90ap.production/
[dean@zippy all_flash.n90ap.production]$ img3decrypt.rb LLB.n90ap.RELEASE.img3 \
&amp;gt; e3b72ddcdc89edf6f29258c7a0e65cba0d808d1a965892515bfff988e3fd5906 \
&amp;gt; 3eb5aa8acbe1386dc13e2673a2546128
Image decrypted OK (bootload)
Writing DATA payload to LLB.n90ap.RELEASE.img3.dec
[dean@zippy all_flash.n90ap.production]$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I like to keep things organized, so I then moved the decrypted version into our &lt;code class=&quot;highlighter-rouge&quot;&gt;decrypted&lt;/code&gt; folder.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy all_flash.n90ap.production]$ mv LLB.n90ap.RELEASE.img3.dec ../../../../decrypted/
[dean@zippy all_flash.n90ap.production]$ cd ../../../../decrypted/
[dean@zippy decrypted]$ ls -1
LLB.n90ap.RELEASE.img3.dec
[dean@zippy decrypted]$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Thanks to the awesome work of the iOS jailbreak scene that’s really all there is to decrypting files in the iOS image.&lt;/p&gt;

&lt;h3 id=&quot;setting-up-in-ida&quot;&gt;Setting Up In IDA&lt;/h3&gt;

&lt;p&gt;This will be the last part covered today.  What we want to do is set things up in IDA so that the addresses are correct and you can then explore on your own.  In my next article I’ll go into more detail about how the binary is laid out and how I actually went about understanding the LLB image at a high-level.&lt;/p&gt;

&lt;p&gt;First thing’s first, let’s open up IDA and load our decrypted image.  To do that, find IDA Pro in your Applications folder then once it’s running go to &lt;strong&gt;File -&amp;gt; Open&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Open.png&quot; alt=&quot;IDA Open File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’ll then be prompted with the “Load a new file” screen.  Here you’ll want to change your processor type from the default Intel selection to ARM.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_ARM.png&quot; alt=&quot;IDA New File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next you’ll be prompted to make any desired changes to the memory organization.  Just click &lt;strong&gt;OK&lt;/strong&gt; for the default choices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Mem.png&quot; alt=&quot;IDA Memory Organization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point IDA should warn you that since you’re loading a raw binary it has no idea how to parse the file.  Because of that, you’ll have to instruct IDA where the entry point is.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Warn.png&quot; alt=&quot;IDA Warning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now our file is loaded, but the addresses are wrong.  The Boot ROM on an iOS Device loads LLB beginning at the address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; so we need to tell IDA that.  You can do this by going to &lt;strong&gt;Edit -&amp;gt; Segments -&amp;gt; Rebase Program…&lt;/strong&gt; and entering &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; into the field.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_GoodBase.png&quot; alt=&quot;IDA Rebase Program&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, we now have LLB loaded with the correct addresses.  All we need to do now is tell IDA where the entry point is and let it do as much of its auto-analysis as possible.  In my next article I’ll explain why this is true, but for now just place the IDA cursor on the byte at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; and mark it as code (hit the &lt;strong&gt;C&lt;/strong&gt; key).  If all goes well IDA should recognize that as a branch instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Code.png&quot; alt=&quot;First instruction marked as code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you should be able to start exploring and begin to reverse engineer LLB.  As an experiment try to find all the strings in the binary and see if you can identify the general layout of the binary.&lt;/p&gt;

&lt;p&gt;Next time I’ll go through the organization of the binary and how I figured it out.  Until then, happy hacking!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Jul 2014 03:57:01 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/07/14/reverse-engineering-the-ios-boot-mechanism-part-1.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/07/14/reverse-engineering-the-ios-boot-mechanism-part-1.html</guid>
        
        
      </item>
    
      <item>
        <title>Snooping on CommCenter</title>
        <description>&lt;p&gt;CommCenter is a wonderful part of iOS since it is the single point that is responsible for communication between iOS and the baseband.  And with the baseband being responsible for controlling the telephony components I wanted to see what CommCenter was telling it.&lt;/p&gt;

&lt;p&gt;To do this all you need to do is create a dynamic library with a few functions then shove that in between CommCenter and the baseband.  Easy, eh?&lt;/p&gt;

&lt;p&gt;Before I begin I should note that I did this using an iPhone 4 running iOS 6.1 (jailbroken) and that on newer iPhones the process is slightly different.&lt;/p&gt;

&lt;p&gt;All code is available on &lt;a href=&quot;https://github.com/lightbulbone/ios&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;creating-the-library&quot;&gt;Creating The Library&lt;/h3&gt;

&lt;p&gt;To intercept the communication between CommCenter and the baseband what you need to do is replace the implementations of &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;.  You can see how to do this in the file &lt;code class=&quot;highlighter-rouge&quot;&gt;ccsnoop.c&lt;/code&gt;, but really the trick is to stick a map between your implementations and the original in a special section called &lt;code class=&quot;highlighter-rouge&quot;&gt;_interpose&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;All that’s necessary now is to compile the code into a dynamic library (see &lt;code class=&quot;highlighter-rouge&quot;&gt;ccsnoop.c&lt;/code&gt; for instructions).&lt;/p&gt;

&lt;h3 id=&quot;loading-the-library&quot;&gt;Loading The Library&lt;/h3&gt;

&lt;p&gt;In order to have the library loaded by CommCenter we first need to alter its plist to include the &lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_INSERT_LIBRARIES&lt;/code&gt; environment variable.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;key&amp;gt;EnvironmentVariables&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
     &amp;lt;key&amp;gt;DYLD_INSERT_LIBRARIES&amp;lt;/key&amp;gt;
     &amp;lt;string&amp;gt;/tmp/ccsnoop.dylib&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The library should be located at &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/ccsnoop.dylib&lt;/code&gt;; a complete plist can be found on GitHub.&lt;/p&gt;

&lt;p&gt;As previously mentioned, the key here is the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_INSERT_LIBRARIES&lt;/code&gt; which forces any specified libraries to be loaded before any libraries specified by CommCenter.  When this is combined with the interposition used in the library we are able to override the default implementations of the desired functions.&lt;/p&gt;

&lt;p&gt;With both the dynamic library and the modified plist we can then restart CommCenter and watch our log file for anything of interest.  To restart CommCenter you can just run the &lt;code class=&quot;highlighter-rouge&quot;&gt;injectCommCenter.sh&lt;/code&gt; script which essentially just uses &lt;code class=&quot;highlighter-rouge&quot;&gt;launchctl&lt;/code&gt; to unload and load it.&lt;/p&gt;

&lt;h3 id=&quot;a-note-about-commcenter&quot;&gt;A Note About CommCenter&lt;/h3&gt;

&lt;p&gt;Beginning in iOS 6 (or earlier, I’m not entirely sure) Apple has created two versions of CommCenter: CommCenterClassic, and CommCenter.  Which is used depends on the hardware you are using.  For example, an iPhone 4 will use CommCenterClassic while an iPhone 5 will use CommCenter.  At this point it’s unclear to me what the difference is between the two; however, I have heard that newer devices use a different protocol to communicate with the baseband.&lt;/p&gt;

&lt;p&gt;Until next time, happy hacking!&lt;/p&gt;

&lt;p&gt;@lightbulbone&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Aug 2013 04:13:59 -0700</pubDate>
        <link>https://www.lightbulbone.com/2013/08/03/snooping-on-commcenter.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/08/03/snooping-on-commcenter.html</guid>
        
        
      </item>
    
      <item>
        <title>iOS Shared Cache Extraction</title>
        <description>&lt;p&gt;Having fallen off the iOS-exploration train due to completing my  Masters and other commitments, I have finally climbed back aboard in pursuit of understanding the telephony stack.&lt;/p&gt;

&lt;p&gt;Like most things in iOS that are used frequently, the vast majority of the frameworks and libraries used in the telephony stack reside in the dyld shared cache located at &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armv7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this post I am going to explain how to go about extracting this cache file so that you can then work with each library individually.&lt;/p&gt;

&lt;h3 id=&quot;get-the-cache&quot;&gt;Get The Cache&lt;/h3&gt;

&lt;p&gt;The first step in all of this is to copy the cache over to your local machine.  I did this using a program called iExplorer, but you can just as easily do it over SSH.  As a side note, you can connect to your iDevice using SSH over USB if you install a tool called iProxy.&lt;/p&gt;

&lt;h3 id=&quot;building-dscextractor&quot;&gt;Building &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The easiest way I found to extract the cache is to use a program provided by Apple called &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.  You can get the source for &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; by downloading the dyld package from Apples open source page at: http://opensource.apple.com/.&lt;/p&gt;

&lt;p&gt;After downloading the package, unarchive it then go to the &lt;code class=&quot;highlighter-rouge&quot;&gt;launch-cache&lt;/code&gt; subdirectory.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy tmp]$ tar -xvzf dyld-210.2.3.tar.gz
[dean@zippy tmp]$ cd dyld-210.2.3/launch-cache/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point we need to apply a patch to the &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; code so that it can be compiled and function properly.  The patch to be applied is available on GitHub at https://gist.github.com/lightbulbone/6092321.&lt;/p&gt;

&lt;p&gt;The patch can be applied using the &lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt; command; once patched &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; can then be compiled.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy launch-cache]$ patch &amp;lt; dsc_extractor.patch
[dean@zippy launch-cache]$ clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You should now have a working copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;extracting-the-cache&quot;&gt;Extracting The Cache&lt;/h3&gt;

&lt;p&gt;The last step is pretty simple.  All you need to do is run &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy com.apple.dyld]$ dsc_extractor dyld_shared_cache_armv7 armv7/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you then look inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;armv7/&lt;/code&gt; folder you’ll find all the extracted libraries used on iOS.&lt;/p&gt;

&lt;p&gt;As a quick side note, you can also open the cache file directly in IDA Pro.  I found this be a bit cumbersome although you may have better luck.&lt;/p&gt;

&lt;p&gt;Until next time, happy hacking!&lt;/p&gt;

</description>
        <pubDate>Fri, 26 Jul 2013 07:27:00 -0700</pubDate>
        <link>https://www.lightbulbone.com/2013/07/26/ios-shared-cache-extraction.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/07/26/ios-shared-cache-extraction.html</guid>
        
        
      </item>
    
      <item>
        <title>Remote debugging with LLDB</title>
        <description>&lt;p&gt;The other day I was working on a project in Xcode and was getting fed up with it crashing and just not behaving.  So I set out on a mission to figure out how to remote debug an iOS app.  The secret to it all is LLDB, the LLVM Debugger.  LLDB is now the default debugger in Xcode (has been for awhile) and is a pretty powerful debugger complete with scripting in Python and many other hidden gems.&lt;/p&gt;

&lt;p&gt;To follow along you will need:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A jailbroken iDevice setup for development&lt;/li&gt;
  &lt;li&gt;Developer Tools (from Xcode) installed on a Mac&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At a high-level this approach works by running a little server on the iDevice and then connecting remotely from your Mac.  To begin, SSH into your iDevice and find some program of interest (such as an iOS app you may be developing).  Then start the debug server on your iDevice.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iPhone:/Applications/FieldTest.app root# /Developer/usr/bin/debugserver localhost:12345 ./FieldTest
debugserver-189 for armv7.
Listening to port 12345...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now on your Mac, we launch LLDB and then connect to the remote session.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@simba ~]$ lldb
(lldb) platform select remote-ios
  Platform: remote-ios
 Connected: no
  SDK Path: &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/6.0.1 (10A523)&quot;
 SDK Roots: [ 0] &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/5.1.1 (9B206)&quot;
 SDK Roots: [ 1] &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/6.0.1 (10A523)&quot;
(lldb) process connect connect://192.168.1.20:12345
Process 2237 stopped
* thread #1: tid = 0x1603, 0x2fe7a028 dyld`_dyld_start, stop reason = signal SIGSTOP
    frame #0: 0x2fe7a028 dyld`_dyld_start
dyld`_dyld_start:
-&amp;gt; 0x2fe7a028:  mov    r8, sp
   0x2fe7a02c:  sub    sp, sp, #16
   0x2fe7a030:  bic    sp, sp, #7
   0x2fe7a034:  ldr    r3, [pc, #112]            ; _dyld_start + 132
(lldb)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point you know have a remote connection to the process being debugged and can use LLDB as you would normally.  Note that this is the exact same way Xcode connects to an app being debugged so anything you can do in Xcode should be possible here.&lt;/p&gt;

&lt;p&gt;Enjoy and happy hacking!&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Jan 2013 11:32:54 -0800</pubDate>
        <link>https://www.lightbulbone.com/2013/01/08/remote-debugging-with-lldb.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/01/08/remote-debugging-with-lldb.html</guid>
        
        
      </item>
    
      <item>
        <title>Fuzzy iOS Messages!</title>
        <description>&lt;p&gt;Awhile ago I came across a post about fuzzing with a new data flow language called Pythonect.  When I read about it I thought it sounded like a pretty nifty language so I decided to try using it to fuzz the iMessage interface in the iOS Messages app.&lt;/p&gt;

&lt;p&gt;The first part of this task is to come up with a way to send messages to an iOS device using the iMessage service.  Luckily the new Messages app on OS X 10.8 has support for AppleScript and you can send messages through it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/usr/bin/osascript

on run argv
    set theMessage to (item 1 of argv)

    tell application &quot;Messages&quot;
         send theMessage to buddy &quot;BUDDY_NAME&quot;
    end tell
end run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this script we tell the Messages application to send a message that was given as an argument to the buddy &lt;code class=&quot;highlighter-rouge&quot;&gt;BUDDY_NAME&lt;/code&gt;.  When you use it be sure to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;BUDDY_NAME&lt;/code&gt; with the correct buddy name you are using.  Also, I saved the script and named it &lt;code class=&quot;highlighter-rouge&quot;&gt;send_msg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;From here it’s quite easy to use Pythonect to do some fuzzing.  For example, the following script will send groups of 4 and 8 A’s, B’s, C’s, and D’s.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] -&amp;gt; [_ * n for n in [4, 8]] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So what else can we do with Pythonect?  Well for starters you can increase the number of characters and messages sent effectively DoSing the device.  You could also mix and match characters to see what outcome that may arrive at.&lt;/p&gt;

&lt;p&gt;I haven’t had much time to play with this but I’ve found that running the following command seems to crash the device.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;*&#39;, &#39;+&#39;, &#39;\&#39;, &#39;/&#39;] -&amp;gt; [_ * n for n in [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000]] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And, this one causes the actual name of the app to be displayed.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&#39;*&#39;] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So there is clearly something going on here, definitely stay tuned for what lurks within!&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Oct 2012 13:42:06 -0700</pubDate>
        <link>https://www.lightbulbone.com/2012/10/19/fuzzy-ios-messages.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2012/10/19/fuzzy-ios-messages.html</guid>
        
        
      </item>
    
      <item>
        <title>Rails - Hex Rays Plugin Contest 2012</title>
        <description>&lt;p&gt;This year I decided to try submitting to the annual Hex Rays plugin contest.  I’m pleased to announce my plugin, Rails.&lt;/p&gt;

&lt;p&gt;Rails is a plugin that simplifies the task of working with multiple instances of IDA Pro.  There are three main advantages to Rails.  First, you won’t go insane trying to work with several instances at once.  Second, your project databases remain uncluttered from the addition of linked libraries and other bits of code.  And third, you don’t need to continuously reverse the same libraries over and over again.&lt;/p&gt;

&lt;p&gt;The plugin is pretty straight forward to use.  Once you’ve opened up a database, just go to Edit-&amp;gt;Plugins-&amp;gt;Rails and enable it.  This will cause a new panel to appear in IDA which lists any other open instances of IDA that are using Rails as well as output from Rails.  With it you can select a function and then see the associated comments or jump to its definition where ever that may be.  Another handy feature is the ability to see the list of open instances and just jump to them by double clicking there name in the list.  For a demo check out the video below.&lt;/p&gt;

&lt;p&gt;If you’d like to work with the code it is available on Github at&lt;/p&gt;

&lt;p&gt;https://github.com/lightbulbone/rails&lt;/p&gt;

&lt;p&gt;.  Note that the plugin currently only builds on Mac OS X; however, I will (very soon) make a build script for Windows.&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Sep 2012 07:25:42 -0700</pubDate>
        <link>https://www.lightbulbone.com/2012/09/14/rails-hex-rays-plugin-contest-2012.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2012/09/14/rails-hex-rays-plugin-contest-2012.html</guid>
        
        
      </item>
    
  </channel>
</rss>
