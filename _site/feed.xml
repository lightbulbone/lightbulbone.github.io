<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LightBulbOne</title>
    <description>One bright idea after another.
</description>
    <link>https://www.lightbulbone.com/</link>
    <atom:link href="https://www.lightbulbone.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 11 Oct 2016 21:02:20 -0700</pubDate>
    <lastBuildDate>Tue, 11 Oct 2016 21:02:20 -0700</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Reversing a macOS Kernel Extension</title>
        <description>&lt;p&gt;In my &lt;a href=&quot;http://lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html&quot;&gt;last post&lt;/a&gt; I covered the basics of kernel debugging in macOS.  In this post we will put some of that to use and work through the process of reversing a macOS kernel module.&lt;/p&gt;

&lt;p&gt;As I said in my last post, in macOS there is a kernel module named “Don’t Steal Mac OS X” (DSMOS) which registers a function with the Mach-O loader to unpack binaries that have the &lt;code class=&quot;highlighter-rouge&quot;&gt;SG_PROTECTED_VERSION_1&lt;/code&gt; flag set on their &lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt; segment. Finder, Dock, and loginwindow are a few examples of binaries that have this flag set.  My goal for this post is to simply work through the kernel module with the intent of discovering its functionality and use it as an opportunity to learn a bit about kernel debugging.&lt;/p&gt;

&lt;p&gt;If you’d like to follow along I pulled the DSMOS module off of a laptop running macOS Sierra Beta (16A286a).  Based on cursory looks at a couple copies from different versions of macOS it hasn’t changed much recently so you should be able to follow along with a copy from Mac OS X 10.11 or macOS Sierra.  As you’ll see in the screenshots, I used IDA Pro for this reversing however using a program like Hopper would be fine as well.&lt;/p&gt;

&lt;h2 id=&quot;first-look&quot;&gt;First Look&lt;/h2&gt;

&lt;p&gt;At a glance, the DSMOS kernel module is fairly simple in terms of number of functions.  It has 25 functions of which we only really care about 6.  Most of the functions we don’t care about are constructors or destructors.  Admittedly I haven’t taken the time to understand constructors and destructors used by a kernel module sp will be skipping them in this post.&lt;/p&gt;

&lt;p&gt;Typically when I first look at a binary I start by looking at the strings in the binary.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-01.png&quot; width=&quot;75%&quot; /&gt;
&lt;figcaption&gt;Figure 1: Strings in DSMOS kernel module&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;As seen in Figure 1, there really aren’t that many strings and they aren’t all that exciting.  The most interesting is probably the string “AppleSMC” which is an indicator that this module interacts with the System Management Controller.&lt;/p&gt;

&lt;p&gt;Given that there are so few functions in this binary my approach was to simply go through each of them, have a quick look at the control flow graph (CFG) for a rough estimate of complexity, and put the function either on the “care” or “don’t care” list.  Doing this I ended up with 9 functions of interest (see Table 1).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Address&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00000A9E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_A9E&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00000B2A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00000D30&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_D30&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00000E9E&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_E9E&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0000125A&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_125A&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00001616&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1616&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00001734&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1734&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00001C48&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1C48&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;00001C94&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1C94&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Table 1: Potentially interesting function addresses and associated names.&lt;/p&gt;

&lt;p&gt;With these functions as starting points, the next step is to start working through them.  At this point our goal is identify what each functionality each provides.&lt;/p&gt;

&lt;h2 id=&quot;registering-an-ioservice-notification-handler&quot;&gt;Registering an IOService Notification Handler&lt;/h2&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-02.png&quot; width=&quot;100%&quot; /&gt;
&lt;figcaption&gt;Figure 2: Main block of code in sub_A9E&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;The relevant block of code from &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_A9E&lt;/code&gt; is shown in Figure 2.  In words, this function first retrieves a matching dictionary for the &lt;code class=&quot;highlighter-rouge&quot;&gt;AppleSMC&lt;/code&gt; service then installs a notification handler that is called when IOKit detects a service with the class name &lt;code class=&quot;highlighter-rouge&quot;&gt;AppleSMC&lt;/code&gt; has been registered.  In the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;IOService::addNotification()&lt;/code&gt; shown in Figure 2 the first argument is the address of the hanlder to be called.  This handler is labelled as &lt;code class=&quot;highlighter-rouge&quot;&gt;notificationHanlder&lt;/code&gt; in Figure 2 and not listed in Table 1 (it was a false negative); its located at address &lt;code class=&quot;highlighter-rouge&quot;&gt;00000B1A&lt;/code&gt; with a default name in IDA of &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B1A&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B1A&lt;/code&gt; isn’t all that interesting, all it does is wrap &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt; dropping some arguments in the process.&lt;/p&gt;

&lt;h2 id=&quot;the-notification-handler&quot;&gt;The Notification Handler&lt;/h2&gt;

&lt;p&gt;When an IOService registers the AppleSMC class the code in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt; will be notified.  This function begins by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;OSMetaClassBase::safeMetaCast()&lt;/code&gt; to cast the incoming service into an AppleSMC service.  Note that Apple’s documentation states that developers should not call OSMetaClassBase methods directly and should instead use provided macros.  In this case, the call &lt;code class=&quot;highlighter-rouge&quot;&gt;safeMetaCast()&lt;/code&gt; was likely generated by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;OSDynamicCast&lt;/code&gt; macro which Apple lists as a valid macro to be used by developers.&lt;/p&gt;

&lt;p&gt;The next block in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt;, shown in Figure 3, is where things actually start.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-03.png&quot; width=&quot;30%&quot; /&gt;
&lt;figcaption&gt;Figure 3: Querying SMC for key&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;Since C++ is horribly annoying to reverse due to all the indirect calls, rather than figuring out what method is represented by &lt;code class=&quot;highlighter-rouge&quot;&gt;rax+850h&lt;/code&gt; I turned to Google.  Searching for &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK1&lt;/code&gt; turns up an &lt;a href=&quot;http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/&quot;&gt;article&lt;/a&gt; posted by Amit Singh.  In it he talks briefly about an older version of the DSMOS kernel extenion and also provides code that uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK1&lt;/code&gt; strings to query the SMC for two keys.  Once these keys have been acquired the kernel extension then computes a SHA-256 hash and compares to a value stored in memory.  If this comparison fails, an error is printed (not shown).&lt;/p&gt;

&lt;p&gt;If the hashes match then we skip to the block shown in Figure 4.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-04.png&quot; width=&quot;30%&quot; /&gt;
&lt;figcaption&gt;Figure 4: Installing DSMOS hook&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;The first part of this basic block takes the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;byte_3AA4&lt;/code&gt; and our keys returned from the SMC then calls &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1616&lt;/code&gt;.  If you look at &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1616&lt;/code&gt; you’ll see it contains a couple loops and a bunch of byte manipulation I didn’t want to reverse.  Looking at where &lt;code class=&quot;highlighter-rouge&quot;&gt;byte_3AA4&lt;/code&gt; is used you’ll see it is used in two places: here in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt; and in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_D30&lt;/code&gt;.  Let’s wait a bit to see how it is used before figuring out how it is generated.&lt;/p&gt;

&lt;p&gt;After the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1616&lt;/code&gt; we have two AES decryption keys set.  The first key is the value returned from the SMC when queried with &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK0&lt;/code&gt; and the second key is the value returned when &lt;code class=&quot;highlighter-rouge&quot;&gt;OSK1&lt;/code&gt; is used to query the SMC.  Finally, we see a global variable named &lt;code class=&quot;highlighter-rouge&quot;&gt;initialized&lt;/code&gt; set to 1 and a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt; with the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_D30&lt;/code&gt; as a parameter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;dsmos_page_transform_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsmos_page_transform_hook_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DSMOS has arrived&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* set the hook now - new callers will run with it */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dsmos_hook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Listing 1: Source code for &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt; from XNU source&lt;/p&gt;

&lt;p&gt;Searching for &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt; in the XNU source we find the code in Listing 1.  This is a pretty simple funciton that simply sets the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt; to the provided function address.&lt;/p&gt;

&lt;h2 id=&quot;usage-of-dsmoshook-in-xnu&quot;&gt;Usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt; in XNU&lt;/h2&gt;

&lt;p&gt;At this point we will take step briefly away from IDA and kernel extension turning our attention to the XNU source.  For this work I used the source of XNU 3248.60.10 which is the version used by Mac OS X 10.11.6.  If you haven’t done so already, you can download the source from &lt;a href=&quot;http://opensource.apple.com/release/os-x-10116/&quot;&gt;http://opensource.apple.com/release/os-x-10116/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we saw, &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt; simply set the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt;.  Continuing from here we find that &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt; is only used in &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt; as we saw and in &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform&lt;/code&gt; (Listing 2).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;dsmos_page_transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolean_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_wait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsmos_hook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first_wait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Waiting for DSMOS...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERN_ABORTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsmos_hook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Listing 2: Usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt; by XNU&lt;/p&gt;

&lt;p&gt;After ensuring &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_hook&lt;/code&gt; the code in LIsting 2 just calls the hook with the parameters passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform&lt;/code&gt;.  This approach allows Apple some flexibility and opens up the opportunity to have multiple hooks in the future. Once again searching the XNU source, we see that the only use of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform&lt;/code&gt; is in a function called &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt;.  I have not included the source of &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt; since it is a bit longer and also not very exciting.  The most interesting part about it is that it checks to see that the segment is long enough before attempting to call &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform&lt;/code&gt; on it.&lt;/p&gt;

&lt;p&gt;Continuing along, &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt; is only called by &lt;code class=&quot;highlighter-rouge&quot;&gt;load_segment&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;load_segment&lt;/code&gt; is a much larger function and is not shown in its entirety but the relevant portion is shown in Listing 3.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SG_PROTECTED_VERSION_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unprotect_dsmos_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;file_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;vp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;pager_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;vm_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;vm_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Listing 3: Call to &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;load_segment&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The interesting part of the code in Listing 3 is that &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt; is only called on segments with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SG_PROTECTED_VERSION_1&lt;/code&gt; flag set.  As mentioned earlier, macOS only includes a few binaries with this flag set such as Finder, Dock, and loginwindow.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-05.png&quot; width=&quot;80%&quot; /&gt;
&lt;figcaption&gt;Figure 5: Main functionality of hook function&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;h2 id=&quot;the-hook-implementation&quot;&gt;The Hook Implementation&lt;/h2&gt;

&lt;p&gt;At this point we know that the DSMOS kernel extension queries the SMC for a pair of keys, initializes some AES decryption contexts and global variables, then installs a hook by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;dsmos_page_transform_hook&lt;/code&gt;.  We also know that the Mach-O loader in the kernel will call this hook when it finds a segment with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SG_PROTECTED_VERSION_1&lt;/code&gt; flag set.  The next question then is: what does the hook installed by the DSMOS kernel extension actually do?&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-05.png&quot; width=&quot;80%&quot; /&gt;
&lt;figcaption&gt;Figure 5: Main functionality of hook function&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;Prior to the code shown in Figure 5 is the function prologue and setting of a stack cookie; after the code is the checking of the stack cookie and function epilogue.  The code shown starts by checking to see if the initialization flag is set.  This is the same initialization flag we saw being set in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt; (see Figure 4).  If this flag is not set the function exits, otherwise it enters a series of checks to identify which kernel is calling the hook.  Searching the XNU source you can find the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2e69cf40&lt;/code&gt; in the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect_dsmos_segment&lt;/code&gt; as shown in Listing 4.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;                &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pager_crypt_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crypt_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;crypt_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_decrypt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dsmos_page_transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;crypt_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crypt_ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;crypt_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crypt_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma unused(vp, macho_offset)
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;crypt_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crypt_ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x2e69cf40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;vm_map_offset_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crypto_backing_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;crypto_backing_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* i.e. use map entry's offset */&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Listing 4: XNU setting value of &lt;code class=&quot;highlighter-rouge&quot;&gt;crypt_info.crypt_ops&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As Figure 5 shows, there are three basic cases implemented in the hook: no protection, an old kernel, and a new kernel.  The basic block responsible for each case is labelled accordingly.  I did not try to figure out which kernels mapped to which version however if you read &lt;a href=&quot;http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/&quot;&gt;the article by Amit Singh&lt;/a&gt; you’ll notice that he talks about the method where each half of the page is encrypted with one of the SMC keys.  In our kernel extension this corresponds to the &lt;code class=&quot;highlighter-rouge&quot;&gt;old_kernel&lt;/code&gt; basic block.&lt;/p&gt;

&lt;p&gt;The method currently in use by Apple starts at the basic block labelled as &lt;code class=&quot;highlighter-rouge&quot;&gt;new_kernel&lt;/code&gt; in Figure 5.  In it we see an 8 byte buffer is zeroed then a call is made to a function I’ve called &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect&lt;/code&gt; (named &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1734&lt;/code&gt; by IDA originally).  Looking at the parameters to &lt;code class=&quot;highlighter-rouge&quot;&gt;unprotect&lt;/code&gt; we see it takes the global buffer &lt;code class=&quot;highlighter-rouge&quot;&gt;byte_3AA4&lt;/code&gt; we saw earlier, the source buffer containing the page to be transformed, and the destination buffer to store the transformed page in among other parameters.&lt;/p&gt;

&lt;p&gt;This is the point in our reversing where things become very tedious since Apple has moved away from using AES to encrypt the pages to a custom method composed of many byte operations (e.g. shift left/right, logical/exclusive or).&lt;/p&gt;

&lt;h2 id=&quot;unprotecting-a-protected-page&quot;&gt;Unprotecting a Protected Page&lt;/h2&gt;

&lt;p&gt;To properly set expectations, due to the tedious nature of this protection mechanism and me being somewhat satisfied with what I’ve learned so far I did not go through the full exercise of reversing Apple’s “unprotect” method.  Originally I had intended to write a program that would be able to apply the transform to a given binary but that program is only partially completed and does not work.  So, with expectations set sufficiently low lets get a feel for the implementation and a couple ways of approaching it.&lt;/p&gt;

&lt;p&gt;First lets step back briefly.  Remember we saw the global variable &lt;code class=&quot;highlighter-rouge&quot;&gt;byte_3AA4&lt;/code&gt; being initialized in &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_B2A&lt;/code&gt; and that I had said the code for that was also incredibly tediuous? Well, thanks to the ability to dump memory from the kernel through the debugger we don’t need to reverse it at all.  We just need to connect to a running kernel and ask it politely.&lt;/p&gt;

&lt;h3 id=&quot;dumping-byte3aa4-from-a-running-kernel&quot;&gt;Dumping &lt;code class=&quot;highlighter-rouge&quot;&gt;byte_3AA4&lt;/code&gt; From a Running Kernel&lt;/h3&gt;

&lt;p&gt;If you are unclear about how to use the kernel debugger then check out my &lt;a href=&quot;http://lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html&quot;&gt;previous post&lt;/a&gt;.  To get started, on your remote machine start the debugger by hitting the NMI keys (left command, right command, and power together) then connect to the debugger from your local machine.  The following lldb sessions shows the steps all put together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-linenos&quot; data-lang=&quot;linenos&quot;&gt;(lldb) kdp-remote 192.168.42.101
Version: Darwin Kernel Version 16.0.0: Fri Aug  5 19:25:15 PDT 2016; root:xnu-3789.1.24~6/DEVELOPMENT_X86_64; UUID=4F6F13D1-366B-3A79-AE9C-4
4484E7FAB18; stext=0xffffff802b000000
Kernel UUID: 4F6F13D1-366B-3A79-AE9C-44484E7FAB18
Load Address: 0xffffff802b000000

...

Process 1 stopped
* thread #2: tid = 0x00b8, 0xffffff802b39a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513, name = '0xffffff8
037046ee0', queue = '0x0', stop reason = signal SIGSTOP
    frame #0: 0xffffff802b39a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513 [opt]
(lldb) showallkexts
OverflowError: long too big to convert
UUID                                 kmod_info            address              size                  id  refs TEXT exec            size     
                         version name                          

...

B97F871A-44FD-3EA4-BC46-8FD682118C79 0xffffff7fadf449a0   0xffffff7fadf41000   0x5000               130     0 0xffffff7fadf41000   0x5000   
                           7.0.0 com.apple.Dont_Steal_Mac_OS_X 

...

(lldb) memory read --force --binary --outfile byte_3AA4.bin 0xffffff7fadf44aa4 0xffffff7fadf44aa4+4172 
4172 bytes written to '/Users/dean/Sites/lightbulbone.github.io/byte_3AA4.bin'&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We start out by connecting to the remote host using the &lt;code class=&quot;highlighter-rouge&quot;&gt;kdp-remote&lt;/code&gt; command.  Once everything has loaded we can get the address of the DSMOS kernel extension in memory using the &lt;code class=&quot;highlighter-rouge&quot;&gt;showallkexts&lt;/code&gt; command.  In my case the base address is &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffff7fadf41000&lt;/code&gt;.  We then read the memory at address &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffff7fadf44aa4&lt;/code&gt; which is the extension base address plus the offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x3aa4&lt;/code&gt;; we read 4172 bytes since that is the size of the buffer.&lt;/p&gt;

&lt;p&gt;If you were writing a program to unprotect binaries you could use this extracted binary blob rather than trying to reverse the initialization algorithm.&lt;/p&gt;

&lt;h3 id=&quot;emulating-the-unprotect-algorithm&quot;&gt;Emulating the Unprotect Algorithm&lt;/h3&gt;

&lt;p&gt;Due to the tedious nature of the algorithm used to “unprotect” a page I decided to try using the &lt;a href=&quot;http://www.unicorn-engine.org/&quot;&gt;Unicorn Engine&lt;/a&gt; to emulate it.  This effort largely failed because it meant I would have to set up memory in Unicorn the same way as it is in the kernel extension and, as I said, the motivation wasn’t quite there.  As far as I know this is possible however it to can be rather tedious; especially in cases where the algorithm isn’t as self-contained as in this case.  Using an IDA plugin such as &lt;a href=&quot;https://github.com/cseagle/sk3wldbg&quot;&gt;sk3wldbg&lt;/a&gt; may help however I was not aware of it at the time.&lt;/p&gt;

&lt;h3 id=&quot;reversing-the-unprotect-algorithm&quot;&gt;Reversing the Unprotect Algorithm&lt;/h3&gt;

&lt;p&gt;In the end I just sat down and started working through the algorithm in IDA.  I did begin to write a program to unprotect before my motivation to work through the tedious code fell through the floor.  For me, looking at DSMOS was an opportunity to learn what a kernel module I’ve known about for many years and become more familiar with the macOS kernel.  That being said a few things a worth pointing out.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-06.png&quot; width=&quot;65%&quot; /&gt;
&lt;figcaption&gt;Figure 6: Loop found in sub_1734&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;In Figure 6 a portion of &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_1734&lt;/code&gt; is shown.  In it we see the first eight bytes of the &lt;code class=&quot;highlighter-rouge&quot;&gt;from&lt;/code&gt; pointer (stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;r14&lt;/code&gt;) being used to build a value to pass to &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_125A&lt;/code&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/2016/10/DSMOS-07.png&quot; width=&quot;20%&quot; /&gt;
&lt;figcaption&gt;Figure 7: Unrolled loop in sub_125A&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;

&lt;p&gt;And, in Figure 7 we see part of &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_125A&lt;/code&gt;.  In this part we see the first two iterations of an unrolled loop.  The point of Figures 6 and 7 is to show some common constructs that come up when reversing code.  If you’re not familiar with these constructs it may help to write some code yourself and then analyze the binary after compilation.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The intent of this post was to reverse engineer the DSMOS kernel extension in macOS.  The goal was to understand what functionality the DSMOS extension provided to the kernel and to become more familiar with the XNU kernel.  We also touched on IOKit briefly as well as a possible application of the Unicorn engine.&lt;/p&gt;

&lt;p&gt;If you have any questions or comments, please feel to reach out to me on Twitter &lt;a href=&quot;https://twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Oct 2016 13:45:00 -0700</pubDate>
        <link>https://www.lightbulbone.com/2016/10/11/dsmos-kext.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2016/10/11/dsmos-kext.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to macOS Kernel Debugging</title>
        <description>&lt;p&gt;In macOS there is a kernel module named “Don’t Steal Mac OS X” (DSMOS) which registers a function with the Mach-O loader to unpack binaries that have the &lt;code class=&quot;highlighter-rouge&quot;&gt;SG_PROTECTED_VERSION_1&lt;/code&gt; flag set on their &lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt; segment. Finder, Dock, and loginwindow are a few examples of binaries that have this flag set.  As it turns out, this kernel module at one point &lt;a href=&quot;http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/&quot;&gt;played a role in the myth&lt;/a&gt; that Apple had included a TPM in their Mac hardware.&lt;/p&gt;

&lt;p&gt;I started reversing this kernel module because I was getting frustrated trying to reverse parts of the iOS kernel.  It occurred to me that I was trying to run before walking so it was time to slow down a little.  With that in mind, this post provides an introduction to kernel debugging.  My next post will expand on this and go through reversing the DSMOS kernel module.&lt;/p&gt;

&lt;h2 id=&quot;kernel-debug-kits&quot;&gt;Kernel Debug Kits&lt;/h2&gt;

&lt;p&gt;Before we jump in, lets first cover why I switched to macOS when getting frustrated with iOS.  The reason is pretty straight forward: macOS and iOS are built from nearly-identical kernel (XNU) source.  In fact all of Apple’s operating systems are.&lt;/p&gt;

&lt;p&gt;The big advantage to starting with macOS is that Apple provides what are known as &lt;strong&gt;Kernel Debug Kits (KDKs)&lt;/strong&gt;.  A KDK provides you with Development and Debug builds of the kernel as well as some useful lldb scripts to help with debugging.  One thing you may be wondering is what is the difference between the Debug and Development builds of the kernel? The short answer, as I understand it, is that the Development kernel is essentially the Release kernel with symbols while the Debug kernel has symbols as well as additional assertions/checks enabled.  For this foray into kernel reversing I used the Development kernel.&lt;/p&gt;

&lt;p&gt;KDKs are provided by Apple and you can download them from &lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;https://developer.apple.com/download/more/&lt;/a&gt;.  When selecting a KDK be sure to choose the one with a kernel version that matches your target machine.  I highly recommend reading the documentation provided with the KDK and will assume you have.&lt;/p&gt;

&lt;h2 id=&quot;configuring-the-kernel-debugger&quot;&gt;Configuring the Kernel Debugger&lt;/h2&gt;

&lt;p&gt;Unlike debugging an application, to debug the kernel you need to use two machines: the target and the host.  The host is where you’ll be running lldb and doing all your work.  The target is the machine that is running the Development kernel and you will be debugging.  For the sake of efficacy, my host is an iMac (Late 2015) running macOS 10.12 (build 16A323) and my target is a Macbook Air (Mid 2011) running macOS 10.12 Beta (16A286aa).&lt;/p&gt;

&lt;p&gt;A word on the target machine: it &lt;strong&gt;does not&lt;/strong&gt; need to be physical hardware.  You can use a virtual machine.  The big difference is that on physical hardware you can easily trigger the kernel debugger using the NMI keys (more on this shortly).  There might be a way to do this in a virtual machine but I had hardware so didn’t bother to figure it out.&lt;/p&gt;

&lt;p&gt;When you install the KDK on your target machine one of the steps is to set &lt;code class=&quot;highlighter-rouge&quot;&gt;boot-args&lt;/code&gt; in nvram.  Mine are set as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airy:~ dean$ nvram boot-args
boot-args       debug=0x14e kcsuffix=development kext-dev-mode=1 kdp_match_name=en4 -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Lets take a moment and go through each of these flags.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kcsuffix&lt;/code&gt; simply instructs the boot loader which kernel it should look for.  In my case I used the Development kernel so &lt;code class=&quot;highlighter-rouge&quot;&gt;kcsuffix&lt;/code&gt; should be set to &lt;code class=&quot;highlighter-rouge&quot;&gt;development&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kext-dev-mode&lt;/code&gt; causes kernel module signing requirements to be relaxed.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; enables verbose mode during boot.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The remaining two variables, &lt;code class=&quot;highlighter-rouge&quot;&gt;kdp_match_name&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;, warrant a bit more discussion than a bullet point.&lt;/p&gt;

&lt;h4 id=&quot;kdpnamematch&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kdp_name_match&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Remote kernel debugging, which we are going to do, requires either Ethernet or FireWire.  It does &lt;em&gt;not&lt;/em&gt; work over WiFi or USB. This obviously begs the question of how one would go about remote debugging with a laptop that has no Ethernet port.  Thankfully, Apple has thought this through and the answer is the &lt;code class=&quot;highlighter-rouge&quot;&gt;kdp_match_name&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;boot-args&lt;/code&gt; variable coupled with a Thunderbolt-to-Ethernet adapter.  You can also use an Apple Cinema display if you have one of those.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;kdp_match_name&lt;/code&gt; variable instructs the kernel to bind the remote debugger to the specified interface.  You can find the interface name using &lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt; and checking which interface has the desired IP assigned.  You also need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;kdp_match_name&lt;/code&gt; if your Mac has multiple Ethernet interfaces.&lt;/p&gt;

&lt;h4 id=&quot;debug&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;The role played by the &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; variable is to configure the kernel debugger.  It’s value is an OR of the &lt;code class=&quot;highlighter-rouge&quot;&gt;DB_*&lt;/code&gt; constants defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;osfmk/kern/debug.h&lt;/code&gt; of the XNU source.  Table 1 documents many of the interesting and not-so-interesting constants.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Flag&lt;/th&gt;
      &lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_HALT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x1&lt;/td&gt;
      &lt;td&gt;Wait for debugger on boot&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_PRT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x2&lt;/td&gt;
      &lt;td&gt;Send &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; output to the console&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_NMI&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x4&lt;/td&gt;
      &lt;td&gt;Activates the kernel debugging facility, including support for NMI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KPRT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x8&lt;/td&gt;
      &lt;td&gt;Send &lt;code class=&quot;highlighter-rouge&quot;&gt;kprintf()&lt;/code&gt; output to remote console&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KDB&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;Use KDB instead of GDB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_SLOG&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x20&lt;/td&gt;
      &lt;td&gt;Enable logging system diagnostics to the system log&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_ARP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x40&lt;/td&gt;
      &lt;td&gt;Allows the kernel debugger nub to use ARP and thus support debugging across subnets.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KDP_BP_DIS&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;Deprecated, was used for old versions of GDB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_LOG_PI_SCRN&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x100&lt;/td&gt;
      &lt;td&gt;Disable the graphical panic screen.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KDP_GETC_ENA&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x200&lt;/td&gt;
      &lt;td&gt;Prompt to enter KDB upon panic&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KERN_DUMP_ON_PANIC&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x400&lt;/td&gt;
      &lt;td&gt;Trigger core dump on panic&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_KERN_DUMP_ON_NMI&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x800&lt;/td&gt;
      &lt;td&gt;Trigger core dump on NMI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_DBG_POST_CORE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x1000&lt;/td&gt;
      &lt;td&gt;Wait in debugger after NMI core&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_PANICLOG_DUMP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x2000&lt;/td&gt;
      &lt;td&gt;Send paniclog on panic,not core&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_REBOOT_POST_CORE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x4000&lt;/td&gt;
      &lt;td&gt;Attempt to reboot after post-panic crashdump/paniclog dump.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_NMI_BTN_ENA&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x8000&lt;/td&gt;
      &lt;td&gt;Enable button to directly trigger NMI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_PRT_KDEBUG&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x10000&lt;/td&gt;
      &lt;td&gt;kprintf KDEBUG traces&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DB_DISABLE_LOCAL_CORE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;0x20000&lt;/td&gt;
      &lt;td&gt;ignore local core dump support&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Table 1: Summary of constants to use in &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; boot-args variable.&lt;/p&gt;

&lt;p&gt;Some of the common values I’ve seen are: 0x141, 0x144, and 0x14e. Note that they all have &lt;code class=&quot;highlighter-rouge&quot;&gt;DB_LOG_PI_SCRN&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DB_ARP&lt;/code&gt; set.&lt;/p&gt;

&lt;h2 id=&quot;using-the-kernel-debugger&quot;&gt;Using the Kernel Debugger&lt;/h2&gt;

&lt;p&gt;Using the remote kernel debugger essentially boils down to installing the target KDK on the host and then running lldb on the host.  You’ll want to install the target KDK on the host so that lldb has access to the symbolicated kernel as well as some handy lldb scripts developed by Apple.  One thing to keep in mind about the remote debugger: it is not always waiting for connections.  Put differently, you can only connect to it at boot if you set &lt;code class=&quot;highlighter-rouge&quot;&gt;DB_HALT&lt;/code&gt;, during a panic, or an NMI if you set &lt;code class=&quot;highlighter-rouge&quot;&gt;DB_NMI&lt;/code&gt;.  Being able to trigger the debugger using the NMI keys (left command, right command, and power all at once) can be very handy if you want to drop into the debugger and inspect the running kernel.&lt;/p&gt;

&lt;p&gt;Once you’ve set your &lt;code class=&quot;highlighter-rouge&quot;&gt;boot-args&lt;/code&gt; on the target and restarted your machine you can start debugging.  Assuming you’ve set your &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; variable to 0x14e once you’re machine has restarted you can trigger the kernel using the NMI keys (left command, right command, power all at once).  When you hit the NMI keys the IP address of the target will be shown on the screen. On your host you can then connect as follows.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) kdp-remote &amp;lt;target-ip&amp;gt;
Version: Darwin Kernel Version 16.0.0: Fri Aug  5 19:25:15 PDT 2016; root:xnu-3789.1.24~6/DEVELOPMENT_X86_64; UUID=4F6F13D1-366B-3A79-AE9C-44484E7FAB18; stext=0xffffff8006000000
Kernel UUID: 4F6F13D1-366B-3A79-AE9C-44484E7FAB18
Load Address: 0xffffff8006000000
Loading kernel debugging from /Library/Developer/KDKs/KDK_10.12_16A286a.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/kernel.py
LLDB version lldb-360.1.50
settings set target.process.python-os-plugin-path &quot;/Library/Developer/KDKs/KDK_10.12_16A286a.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/core/operating_system.py&quot;
Target arch: x86_64
Instantiating threads completely from saved state in memory.
settings set target.trap-handler-names hndl_allintrs hndl_alltraps trap_from_kernel hndl_double_fault hndl_machine_check _fleh_prefabt _ExceptionVectorsBase _ExceptionVectorsTable _fleh_undef _fleh_dataabt _fleh_irq _fleh_decirq _fleh_fiq_generic _fleh_dec
command script import &quot;/Library/Developer/KDKs/KDK_10.12_16A286a.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/xnu.py&quot;
xnu debug macros loaded successfully. Run showlldbtypesummaries to enable type summaries.


Kernel slid 0x5e00000 in memory.
Loaded kernel file /Library/Developer/KDKs/KDK_10.12_16A286a.kdk/System/Library/Kernels/kernel.development
Loading 119 kext modules warning: Can't find binary/dSYM for com.apple.kec.corecrypto (700E1192-8CD6-3F61-ABE9-D27C2CC1F164)

/*-- removed for clarity --*/

. done.
Target arch: x86_64
Instantiating threads completely from saved state in memory.
kernel.development was compiled with optimization - stepping may behave oddly; variables may not be available.
Process 1 stopped
* thread #2: tid = 0x00b6, 0xffffff800639a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513, name = '0xffffff8011639cf0', queue = '0x0', stop reason = signal SIGSTOP
    frame #0: 0xffffff800639a3de kernel.development`Debugger [inlined] hw_atomic_sub(delt=1) at locks.c:1513 [opt]
(lldb)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point you can use lldb as you normally would.  You will also have a bunch of additional commands provided throught the KDK.  For example you can list all kexts like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) showallkexts 
OverflowError: long too big to convert
UUID                                 kmod_info            address              size                  id  refs TEXT exec            size     
                         version name                          
0490CEBA-045D-344E-AC8B-1449598798F6 0xffffff7f88fdf528   0xffffff7f88fdb000   0x5000               147     0 0xffffff7f88fdb000   0x5000   
                            1.70 com.apple.driver.AudioAUUC    
92511291-6B64-35B1-A824-53034DEBDD39 0xffffff7f88fdacb8   0xffffff7f88fd6000   0x5000               146     0 0xffffff7f88fd6000   0x5000   
                         1.9.5d0 com.apple.driver.AppleHWSensor
EDC33E0C-CAA2-3E79-951D-1FC392284B4D 0xffffff7f88fd5508   0xffffff7f88fcd000   0x9000               145     0 0xffffff7f88fcd000   0x9000   
                             3.0 com.apple.filesystems.autofs  
CCC57A89-31FE-3D9F-88A3-0EC7D254477B 0xffffff7f88fcb028   0xffffff7f88fc8000   0x5000               144     1 0xffffff7f88fc8000   0x5000   
                             1.0 com.apple.kext.triggers       
E6E68296-809B-3884-ADEF-E85831F4B106 0xffffff7f88fc7090   0xffffff7f88fbb000   0xd000               143     0 0xffffff7f88fbb000   0xd000   
                               1 com.apple.driver.pmtelemetry  
                           
/*-- removed for clarity --*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To find all the commands available to lldb just type &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt; at the prompt.  The KDK adds a lot of them rather than going through them in this post your better off taking the time to pick a few interesting ones and seeing what they do.&lt;/p&gt;

&lt;p&gt;At this point, you should be able to setup remote kernel debugging in macOS and be able to inspect a running kernel.  In the next post I will put some of this to use and look at the DSMOS kernel module.&lt;/p&gt;

</description>
        <pubDate>Tue, 04 Oct 2016 01:30:00 -0700</pubDate>
        <link>https://www.lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2016/10/04/intro-to-macos-kernel-debugging.html</guid>
        
        
      </item>
    
      <item>
        <title>Analysis of the iOS Bluetooth Stack: BlueTool</title>
        <description>&lt;p&gt;On iOS the Bluetooth stack is split into three layers as shown in Figure 1.  At the top is the CoreBluetooth framework used by iOS app developers and at the bottom is the Bluetooth hardware itself.  In between these two layers is a collection of daemons that implement various aspects of the Bluetooth stack.  For example, most Bluetooth Low Energy (BLE) specific functionality is contained in the BTLEServer daemon.  BlueTool is one of the daemons running and is primarily responsible for acting as a bridge between the rest of the Bluetooth stack and the hardware.  It also likely acts as an internal test tool at Apple during development.&lt;/p&gt;

&lt;p&gt;All analysis in this article was carried out on a 5th generation iPod Touch running iOS 8.4 (12H143).  My primary focus during analysis was on understanding what functionality BlueTool provides.  I was not actively looking for bugs despite finding a couple.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[[/assets/images/2015/12/iOS-Bluetooth-Overview.png&lt;/td&gt;
      &lt;td&gt;alt=”Overview of the iOS Bluetooth stack.”]]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;bluetool-io-mechanisms&quot;&gt;BlueTool I/O Mechanisms&lt;/h2&gt;

&lt;p&gt;BlueTool is started automatically at boot by launchd and may also be started manually.  When it is started automatically by launchd, BlueTool is executed with an undocumented &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; flag that can be seen by either inspecting the running processes or looking at the launchd plist file for the executable.  If BlueTool is started manually it will drop the user into an interactive shell as shown in the listing below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Welcome to BlueTool... Rev 6.0

&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;?
BlueTool Help
  ?                : Print out all commands and some help.
  autobaud         : Run automatic baud rate on the selected device.
  device           : Select the device to communicate over.
  hci              : Send an HCI &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;to the Bluetooth device.
  bcm              : Broadcom specific operations.
  msleep           : Sleep the &lt;span class=&quot;nb&quot;&gt;caller &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the given number of milliseconds
  spam             : Spam data to the UART
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;               : &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &amp;lt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&amp;gt; ? a : b
  &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;             : &lt;span class=&quot;nb&quot;&gt;true
  false&lt;/span&gt;            : &lt;span class=&quot;nb&quot;&gt;false
  echo&lt;/span&gt;             : &lt;span class=&quot;nb&quot;&gt;echo
  &lt;/span&gt;power            : Power on/off the Bluetooth device.
  reset            : Reset on/off/pulse the Bluetooth device.
  wake             : Wake on/off/pulse the Bluetooth device.
Give any commands &lt;span class=&quot;s1&quot;&gt;'-h'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more details.
device returned 3
&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;device -D
Opening com.apple.uart.bluetooth @ 115200 baud.
&lt;span class=&quot;gp&quot;&gt;bluetool-&amp;gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When BlueTool is started by launchd it creates an XPC service called &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.BlueTool&lt;/code&gt; and ignores all input from stdin.  Most output is logged to stdout or stderr.&lt;/p&gt;

&lt;p&gt;In addition to the interactive shell and XPC service, data is also sent to and received from the Bluetooth hardware.  This communication is carried out over a UART connection and uses the Bluetooth Host-Controller Interface (HCI) command set.&lt;/p&gt;

&lt;h2 id=&quot;xpc-service&quot;&gt;XPC Service&lt;/h2&gt;

&lt;p&gt;When BlueTool is started by launchd the undocumented &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; flag causes two things to happen:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BlueTool starts the &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.BlueTool&lt;/code&gt; XPC service&lt;/li&gt;
  &lt;li&gt;BlueTool ignores all commands passed to it via stdin&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The XPC service handler first asserts that the message dictionary contains the &lt;code class=&quot;highlighter-rouge&quot;&gt;kBluetoolMessageId&lt;/code&gt; key and then selects a command-specific handler based on its value.  Possible values are 2 through 5 inclusive.  Note that the values 0 and 1 are not bound to any handler, it is unclear to me why.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; kBluetoolMessageId &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; Description &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Undefined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Undefined.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process given file path as script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process named script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Process &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; separated list of commands.  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; Return version information.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The following are summaries of each command.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-2&quot;&gt;XPC Command: 2&lt;/h3&gt;

&lt;p&gt;Setting kBluetoolMessageId equal to two causes the program to then look for the &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; key.  The value of this key is a string that contains a path to a script to be run by BlueTool.  The script file is simply a single command per line.&lt;/p&gt;

&lt;p&gt;During testing I noticed that the file is opened using &lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt; with no checks beforehand to ensure the path is valid.  As a result it is possible to read files at other locations.  Although this is a directory traversal vulnerability there are two caveats:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The sandbox should block reads to unauthorized files&lt;/li&gt;
  &lt;li&gt;Data read is sent to stderr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since my testing was on a jailbroken device it is unclear to me if the sandbox had been disabled.  I did find it possible to read &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt; however this should be tested on a non-jailbroken device.  Regardless, due to the BlueTool process being started by launchd we typically don’t have control or access to stderr.  As a result, this bug is likely not very interesting.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-3&quot;&gt;XPC Command: 3&lt;/h3&gt;

&lt;p&gt;This command allows a client of the XPC service to execute a named script.  The three script names I’ve found so far are: boot, init, and deepsleep.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-4&quot;&gt;XPC Command: 4&lt;/h3&gt;

&lt;p&gt;When kBluetoolMessageId is set to 4 BlueTool will then search for a dictionary key of &lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;.  The string associated with this key is then split into substrings using &lt;code class=&quot;highlighter-rouge&quot;&gt;strtok&lt;/code&gt; and passed to the central command processor used by both the XPC service and the interactive shell.&lt;/p&gt;

&lt;h3 id=&quot;xpc-command-5&quot;&gt;XPC Command: 5&lt;/h3&gt;

&lt;p&gt;The final command simply replies with the chip model, firmware version, and manufacturer as strings. This command takes no inputs.&lt;/p&gt;

&lt;h2 id=&quot;bluetool-commands&quot;&gt;BlueTool Commands&lt;/h2&gt;

&lt;p&gt;As was shown previously, BlueTool supports a number of commands.  Most commands accept the &lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; flag to show additional information about the command.  Two commands that I looked at in particular are &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm&lt;/code&gt;.  Before executing most commands it is expected that you connect to a device via the &lt;code class=&quot;highlighter-rouge&quot;&gt;device&lt;/code&gt; command.&lt;/p&gt;

&lt;h3 id=&quot;spam-segfault&quot;&gt;Spam Segfault&lt;/h3&gt;

&lt;p&gt;Shortly after I began experimenting with the interactive shell I noticed that executing the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command lead to a segfault.  Being hopeful that I may be able to turn this bug into something useful I decided to investigate it.&lt;/p&gt;

&lt;p&gt;Connecting to BlueTool with LLDB and passing the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command I found that BlueTool was crashing due to trying to branch to the address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt;.  This happened because I was not opening a device beforehand.  Opening a device is required because BlueTool tries to abstract away the hardware to some degree by placing a set of function pointers in memory when opening the device.  These function pointers provide hardware specific functionality.  Since the &lt;code class=&quot;highlighter-rouge&quot;&gt;spam&lt;/code&gt; command does not first ensure a device is open it will blindly try to branch to the address stored in the function pointer.  For more on the function pointers and other data stored when opening a device see the section titled &lt;em&gt;The 0x400 Structure&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;downloading-firmware-to-the-bluetooth-module&quot;&gt;Downloading Firmware to the Bluetooth Module&lt;/h3&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm&lt;/code&gt; command offers a subcommand that allows you to specify the path of a &lt;code class=&quot;highlighter-rouge&quot;&gt;.hcd&lt;/code&gt; file (Broadcom firmware) to download.  I am still in the process of dumping and reversing the firmware, however the presence of this command means it is possible to update the Bluetooth module.&lt;/p&gt;

&lt;h2 id=&quot;the-0x400-structure&quot;&gt;The 0x400 Structure&lt;/h2&gt;

&lt;p&gt;Through out the binary there is heavy use of what I’ve dubbed “the 0x400 structure”.  This name came to be because this structure is always referenced by adding 0x400 to a base register.  The structure contains the following.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; Offset &lt;/th&gt;
      &lt;th&gt; Value &lt;/th&gt;
      &lt;th&gt; Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x400 &lt;/td&gt;
      &lt;td&gt; socket &lt;/td&gt;
      &lt;td&gt; UART socket file descriptor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x404 &lt;/td&gt;
      &lt;td&gt; open &lt;/td&gt;
      &lt;td&gt; boolean value indicating if device is open or closed  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x408 &lt;/td&gt;
      &lt;td&gt; 0x19eb1 &lt;/td&gt;
      &lt;td&gt; write to socket (1 byte max)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x40c &lt;/td&gt;
      &lt;td&gt; 0x19eb9 &lt;/td&gt;
      &lt;td&gt; write to socket (R2 bytes max)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x410 &lt;/td&gt;
      &lt;td&gt; 0x19ec1 &lt;/td&gt;
      &lt;td&gt; call select() on socket.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x414 &lt;/td&gt;
      &lt;td&gt; 0x19f41 &lt;/td&gt;
      &lt;td&gt; a more different write&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x418 &lt;/td&gt;
      &lt;td&gt; 0x19fa1 &lt;/td&gt;
      &lt;td&gt; read H4 HCI event/cmd/data body/header&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x41c &lt;/td&gt;
      &lt;td&gt; 0x19e25 &lt;/td&gt;
      &lt;td&gt; set baud rate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x420 &lt;/td&gt;
      &lt;td&gt; 0x1a175 &lt;/td&gt;
      &lt;td&gt; close UART socket&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x424 &lt;/td&gt;
      &lt;td&gt; 0x1a191 &lt;/td&gt;
      &lt;td&gt; flush the socket, input and output&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x428 &lt;/td&gt;
      &lt;td&gt; 0x1a199 &lt;/td&gt;
      &lt;td&gt; spam 0xAA to UART&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0x42c &lt;/td&gt;
      &lt;td&gt; 0x0 &lt;/td&gt;
      &lt;td&gt; set via STR at 0x19d84&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The values stored in this structure were obtained by inspecting the memory of a running BlueTool process and mapped to there offset through analysis of the open-device function.&lt;/p&gt;

&lt;h2 id=&quot;uart-and-hci&quot;&gt;UART and HCI&lt;/h2&gt;

&lt;p&gt;Communication between BlueTool and the Bluetooth module occurs over a UART connection. The protocol used over this connection is the standard HCI protocol specified by the Bluetooth specification.  BlueTool makes use of various vendor-specific HCI commands.  Since Broadcom does not seem to release datasheets and documentation describing the various commands the following list was compiled based off strings in the binary as well as the Broadcom patchram tool at &lt;a href=&quot;https://code.google.com/p/broadcom-bluetooth/&quot;&gt;https://code.google.com/p/broadcom-bluetooth/&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; OpCode &lt;/th&gt;
      &lt;th&gt; Description &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC01 &lt;/td&gt;
      &lt;td&gt; Write Bluetooth device address&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC18 &lt;/td&gt;
      &lt;td&gt; Update baud rate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC1C &lt;/td&gt;
      &lt;td&gt; Write SCO PCM int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC1E &lt;/td&gt;
      &lt;td&gt; Write PCM data format&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC2E &lt;/td&gt;
      &lt;td&gt; Download mini driver&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC27 &lt;/td&gt;
      &lt;td&gt; Write sleep mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC45 &lt;/td&gt;
      &lt;td&gt; Write UART clock setting 48 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC4C &lt;/td&gt;
      &lt;td&gt; Copy bytes to destination address  &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC4E &lt;/td&gt;
      &lt;td&gt; Unknown&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; 0xFC6D &lt;/td&gt;
      &lt;td&gt; Write i2spcm interface parameter&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;The default UART device is opened by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;socket()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;connect()&lt;/code&gt; with the device string &lt;code class=&quot;highlighter-rouge&quot;&gt;com.apple.uart.Bluetooth&lt;/code&gt;.  Other device nodes found are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btpoweroff&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btreset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/btwake&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/cu.bluetooth&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/tty.bluetooth&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/uart.bluetooth&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future Work&lt;/h2&gt;

&lt;p&gt;Moving forward with my analysis of the iOS Bluetooth stack I see the following as interesting next steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Analysis of BTServer and BTLEServer&lt;/li&gt;
  &lt;li&gt;Reverse engineering of the Broadcom firmware blobs&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As I have previously mentioned, my goal for this analysis is to document and understand the iOS Bluetooth stack.  Both of these next steps will help further my understanding and I hope will provide a basis for others to work off of.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Dec 2015 01:15:09 -0800</pubDate>
        <link>https://www.lightbulbone.com/2015/12/27/bluetool.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2015/12/27/bluetool.html</guid>
        
        
      </item>
    
      <item>
        <title>Wargames and CTFs</title>
        <description>&lt;p&gt;One great way to practice your skills in the pentesting world is to participate in wargames and CTFs.  You can play wargames on sites like &lt;a href=&quot;http://overthewire.org/wargames/&quot;&gt;OverTheWire&lt;/a&gt; or &lt;a href=&quot;http://www.smashthestack.org/&quot;&gt;SmashTheStack&lt;/a&gt;, take part in sanctioned CTFs such as those through &lt;a href=&quot;http://ctf365.com/&quot;&gt;CTF365&lt;/a&gt;, or setup your own lab at home and play around in it.&lt;/p&gt;

&lt;p&gt;This afternoon I thought it’d be fun to play a quick wargame and decided there might be some educational benefit to others by sharing my notes.  The game I chose was &lt;code class=&quot;highlighter-rouge&quot;&gt;Leviathan&lt;/code&gt; on OverTheWire, it’s fairly easy but a good starting point for those new to this and a fun hour or so for those not so new.&lt;/p&gt;

&lt;p&gt;Check out my notes on my &lt;a href=&quot;https://github.com/lightbulbone/wargames&quot;&gt;GitHub repository&lt;/a&gt;.  Feel free to message me if you have any questions!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Aug 2014 09:57:41 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/08/12/wargames-and-ctfs.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/08/12/wargames-and-ctfs.html</guid>
        
        
      </item>
    
      <item>
        <title>IDA Processor Options - Oops.</title>
        <description>&lt;p&gt;So I’ve been working through the LLB code that I talked about in my last article and kept running into incorrectly decoded instructions.  I knew they were wrong because (A) the output IDA was giving made no sense and (B) I manually decoded some of them myself to check it.&lt;/p&gt;

&lt;p&gt;The problem? I forgot to set the processor options when loading the LLB binary.&lt;/p&gt;

&lt;p&gt;So, take my mistake as a learning experience.  When loading your binary, be sure to set your processor type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2014/Jul/Load_IDA-phg.png&quot; alt=&quot;IDA Pro Load File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And then, the important part, set the processor options.  In this case the default architecture selected by the ARM processor module was not inline with the architecture used by the LLB code.  For LLB, be sure to select &lt;strong&gt;ARMv7-AR&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2014/Jul/ARM_Options.png&quot; alt=&quot;ARM Processor Options&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Live and learn,&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Jul 2014 08:58:33 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/07/21/ida-processor-options-oops.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/07/21/ida-processor-options-oops.html</guid>
        
        
      </item>
    
      <item>
        <title>Reverse Engineering The iOS Boot Mechanism (Part 1)</title>
        <description>&lt;p&gt;Due to some unforeseen medical issues, my time as an elite athlete adbruptly came to an end a couple months ago and while dealing with those issues I had a lot of free time on my hands.  So, naturally I finally got around to reading &lt;a href=&quot;http://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542&quot;&gt;Mac OS X Internals: A Systems Approach&lt;/a&gt; by Amit Singh and &lt;a href=&quot;http://www.amazon.com/Mac-OS-iOS-Internals-Apples/dp/1118057651&quot;&gt;Mac OS X and iOS Internals: To the Apple’s Core&lt;/a&gt; by Johnathan Levin in their entirety.  Both are excellent books and highly recommended.  Between reading those books, my general curiousity in low-level computer concepts, and an even greater curiousity in mobile computing I decided it was time to take a crack at reverse engineering the iOS boot mechnisms.&lt;/p&gt;

&lt;h3 id=&quot;components-of-the-boot-mechanism&quot;&gt;Components of the Boot Mechanism&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/Components.png&quot; alt=&quot;iOS Boot Components&quot; title=&quot;iOS Boot Components&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before diving into setting up for decrypting and dissasembling the various components let’s first take a quick look at an overview of the boot sequence.&lt;/p&gt;

&lt;p&gt;It all starts in the &lt;em&gt;Boot ROM&lt;/em&gt;.  This bit of code is flashed onto the device during chip fabrication and can’t be updated.  It contains the Apple Root CA certificate and is responsible for checking the integrity of the second stage bootloader, &lt;em&gt;Low-Level Bootloader (LLB)&lt;/em&gt;.  The Boot ROM performs some initialization tasks and will either proceed to load LLB or move towards DFU mode through &lt;em&gt;iBSS&lt;/em&gt; and &lt;em&gt;iBEC&lt;/em&gt;.  LLB and the third stage bootloader, &lt;em&gt;iBoot&lt;/em&gt;, are tasked with the job of initializing the remaining hardware components and eventually loading the kernel.  Both LLB and iBoot are stored on the filesystem meaning that they can be updated through an iOS upgrade.  We’ll see more of the specifics in future blog posts as I work through the various components.&lt;/p&gt;

&lt;h3 id=&quot;getting-the-pieces&quot;&gt;Getting The Pieces&lt;/h3&gt;

&lt;p&gt;Before we can begin, we need to gather a few pieces and establish a consistent work environment.  To follow along you will need:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mac OS X &amp;gt;= 10.8 (Mountain Lion)&lt;/li&gt;
  &lt;li&gt;iOS 7.0.4 IPSW (iOS: 7.0.4, Build: 11B554a, Device: iPhone3,1)&lt;/li&gt;
  &lt;li&gt;img3decrypt.rb&lt;/li&gt;
  &lt;li&gt;IDA Pro&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In theory you can use any version of iOS, the reason for iOS 7.0.4 is that I have an iPhone 4 running that and eventually plan on translating some of this reversing into fun tricks on the device.  If you don’t have a license for IDA Pro then you can accomplish everything using the &lt;a href=&quot;http://hopperapp.com/&quot;&gt;Hopper Disassember&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find links to all recently released iOS images along with the corresping key/IV pairs on the fabulous &lt;a href=&quot;http://www.icj.me/&quot;&gt;http://www.icj.me/&lt;/a&gt;.  The image and key/IV pairs we’re interested in can be found at &lt;a href=&quot;http://www.icj.me/ios/keys/iPhone3,1/11B554a&quot;&gt;http://www.icj.me/ios/keys/iPhone3,1/11B554a&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next piece you’ll want to grab is the &lt;a href=&quot;https://github.com/pod2g/ios_stuff/blob/master/misc-hs07/img3decrypt.rb&quot;&gt;img3decrypt.rb&lt;/a&gt; script created by pod2g.  To use img3decrypt.rb you’ll also need Ruby installed.&lt;/p&gt;

&lt;h3 id=&quot;unpacking-the-ipsw&quot;&gt;Unpacking the IPSW&lt;/h3&gt;

&lt;p&gt;Before we unpack the IPSW it’s important to keep your workspace organized.  I like to use a folder structure such as the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Reversing/iOS/7.0.4/iPhone3,1/decrypted/
~/Reversing/iOS/7.0.4/iPhone3,1/ipsw/
~/Reversing/iOS/7.0.4/iPhone3,1/unpacked/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next up, we need to unpack the iOS image (IPSW).  This is pretty easy since an &lt;code class=&quot;highlighter-rouge&quot;&gt;.ipsw&lt;/code&gt; is actually just a ZIP-file in disguise.  Go ahead and tack a &lt;code class=&quot;highlighter-rouge&quot;&gt;.zip&lt;/code&gt; onto the image name and then unzip it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy iPhone3,1]$ cd ipsw/
[dean@zippy ipsw]$ mv iPhone3,1_7.0.4_11B554a_Restore.ipsw iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip
[dean@zippy ipsw]$ unzip iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip -d ../unpacked/
Archive:  iPhone3,1_7.0.4_11B554a_Restore.ipsw.zip
  inflating: ../unpacked/058-1056-002.dmg  
  inflating: ../unpacked/058-1086-002.dmg  
  inflating: ../unpacked/058-1139-002.dmg  

  ... snip ...

   creating: ../unpacked/Firmware/usr/
   creating: ../unpacked/Firmware/usr/local/
   creating: ../unpacked/Firmware/usr/local/standalone/
  inflating: ../unpacked/kernelcache.release.n90  
  inflating: ../unpacked/Restore.plist  
[dean@zippy ipsw]$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point you should have an unpacked copy of the iOS image in your &lt;code class=&quot;highlighter-rouge&quot;&gt;unpacked&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&quot;decrypting-llb&quot;&gt;Decrypting LLB&lt;/h3&gt;

&lt;p&gt;Once we’ve unpacked the iOS image the next thing we need to do is decrypt the LLB binary.  Like most files in the iOS image, the LLB binary is contained inside an IMG3 file with the data section encrypted using a key that the iOS device derives during the upgrade process.  Therefore, in order to get at the data we first need the key and associated initialization vector (IV) for the LLB binary.  Note that the key/IV pair is different for each file in the iOS image as well as for each device and build version combination.&lt;/p&gt;

&lt;p&gt;Now, let’s get started.  The first thing we’ll want to do is grab the key and IV from &lt;a href=&quot;http://www.icj.me/ios/keys/iPhone3,1/11B554a&quot;&gt;http://www.icj.me/ios/keys/iPhone3,1/11B554a&lt;/a&gt;.  I’ve also copied the key/IV pair below to simplify things.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Key: e3b72ddcdc89edf6f29258c7a0e65cba0d808d1a965892515bfff988e3fd5906
IV:  3eb5aa8acbe1386dc13e2673a2546128
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Once we have that, open up your terminal and move to the directory where the LLB binary is.  Once you’re there, just run img3decrypt.rb and it should report that the decryption succeeded and it created a &lt;code class=&quot;highlighter-rouge&quot;&gt;.dec&lt;/code&gt; file.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;.dec&lt;/code&gt; contains the decrypted version of LLB.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy ~]$ cd ~/Reversing/iOS/7.0.4/iPhone3,1/unpacked/Firmware/all_flash/all_flash.n90ap.production/
[dean@zippy all_flash.n90ap.production]$ img3decrypt.rb LLB.n90ap.RELEASE.img3 \
&amp;gt; e3b72ddcdc89edf6f29258c7a0e65cba0d808d1a965892515bfff988e3fd5906 \
&amp;gt; 3eb5aa8acbe1386dc13e2673a2546128
Image decrypted OK (bootload)
Writing DATA payload to LLB.n90ap.RELEASE.img3.dec
[dean@zippy all_flash.n90ap.production]$
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I like to keep things organized, so I then moved the decrypted version into our &lt;code class=&quot;highlighter-rouge&quot;&gt;decrypted&lt;/code&gt; folder.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy all_flash.n90ap.production]$ mv LLB.n90ap.RELEASE.img3.dec ../../../../decrypted/
[dean@zippy all_flash.n90ap.production]$ cd ../../../../decrypted/
[dean@zippy decrypted]$ ls -1
LLB.n90ap.RELEASE.img3.dec
[dean@zippy decrypted]$ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Thanks to the awesome work of the iOS jailbreak scene that’s really all there is to decrypting files in the iOS image.&lt;/p&gt;

&lt;h3 id=&quot;setting-up-in-ida&quot;&gt;Setting Up In IDA&lt;/h3&gt;

&lt;p&gt;This will be the last part covered today.  What we want to do is set things up in IDA so that the addresses are correct and you can then explore on your own.  In my next article I’ll go into more detail about how the binary is laid out and how I actually went about understanding the LLB image at a high-level.&lt;/p&gt;

&lt;p&gt;First thing’s first, let’s open up IDA and load our decrypted image.  To do that, find IDA Pro in your Applications folder then once it’s running go to &lt;strong&gt;File -&amp;gt; Open&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Open.png&quot; alt=&quot;IDA Open File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’ll then be prompted with the “Load a new file” screen.  Here you’ll want to change your processor type from the default Intel selection to ARM.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_ARM.png&quot; alt=&quot;IDA New File Dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next you’ll be prompted to make any desired changes to the memory organization.  Just click &lt;strong&gt;OK&lt;/strong&gt; for the default choices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Mem.png&quot; alt=&quot;IDA Memory Organization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point IDA should warn you that since you’re loading a raw binary it has no idea how to parse the file.  Because of that, you’ll have to instruct IDA where the entry point is.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Warn.png&quot; alt=&quot;IDA Warning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now our file is loaded, but the addresses are wrong.  The Boot ROM on an iOS Device loads LLB beginning at the address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; so we need to tell IDA that.  You can do this by going to &lt;strong&gt;Edit -&amp;gt; Segments -&amp;gt; Rebase Program…&lt;/strong&gt; and entering &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; into the field.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_GoodBase.png&quot; alt=&quot;IDA Rebase Program&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, we now have LLB loaded with the correct addresses.  All we need to do now is tell IDA where the entry point is and let it do as much of its auto-analysis as possible.  In my next article I’ll explain why this is true, but for now just place the IDA cursor on the byte at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x84000000&lt;/code&gt; and mark it as code (hit the &lt;strong&gt;C&lt;/strong&gt; key).  If all goes well IDA should recognize that as a branch instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2014/07/IDA_Code.png&quot; alt=&quot;First instruction marked as code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you should be able to start exploring and begin to reverse engineer LLB.  As an experiment try to find all the strings in the binary and see if you can identify the general layout of the binary.&lt;/p&gt;

&lt;p&gt;Next time I’ll go through the organization of the binary and how I figured it out.  Until then, happy hacking!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/lightbulbone&quot;&gt;@lightbulbone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Jul 2014 03:57:01 -0700</pubDate>
        <link>https://www.lightbulbone.com/2014/07/14/reverse-engineering-the-ios-boot-mechanism-part-1.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2014/07/14/reverse-engineering-the-ios-boot-mechanism-part-1.html</guid>
        
        
      </item>
    
      <item>
        <title>Snooping on CommCenter</title>
        <description>&lt;p&gt;CommCenter is a wonderful part of iOS since it is the single point that is responsible for communication between iOS and the baseband.  And with the baseband being responsible for controlling the telephony components I wanted to see what CommCenter was telling it.&lt;/p&gt;

&lt;p&gt;To do this all you need to do is create a dynamic library with a few functions then shove that in between CommCenter and the baseband.  Easy, eh?&lt;/p&gt;

&lt;p&gt;Before I begin I should note that I did this using an iPhone 4 running iOS 6.1 (jailbroken) and that on newer iPhones the process is slightly different.&lt;/p&gt;

&lt;p&gt;All code is available on &lt;a href=&quot;https://github.com/lightbulbone/ios&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;creating-the-library&quot;&gt;Creating The Library&lt;/h3&gt;

&lt;p&gt;To intercept the communication between CommCenter and the baseband what you need to do is replace the implementations of &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;.  You can see how to do this in the file &lt;code class=&quot;highlighter-rouge&quot;&gt;ccsnoop.c&lt;/code&gt;, but really the trick is to stick a map between your implementations and the original in a special section called &lt;code class=&quot;highlighter-rouge&quot;&gt;_interpose&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;All that’s necessary now is to compile the code into a dynamic library (see &lt;code class=&quot;highlighter-rouge&quot;&gt;ccsnoop.c&lt;/code&gt; for instructions).&lt;/p&gt;

&lt;h3 id=&quot;loading-the-library&quot;&gt;Loading The Library&lt;/h3&gt;

&lt;p&gt;In order to have the library loaded by CommCenter we first need to alter its plist to include the &lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_INSERT_LIBRARIES&lt;/code&gt; environment variable.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;key&amp;gt;EnvironmentVariables&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
     &amp;lt;key&amp;gt;DYLD_INSERT_LIBRARIES&amp;lt;/key&amp;gt;
     &amp;lt;string&amp;gt;/tmp/ccsnoop.dylib&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The library should be located at &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/ccsnoop.dylib&lt;/code&gt;; a complete plist can be found on GitHub.&lt;/p&gt;

&lt;p&gt;As previously mentioned, the key here is the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_INSERT_LIBRARIES&lt;/code&gt; which forces any specified libraries to be loaded before any libraries specified by CommCenter.  When this is combined with the interposition used in the library we are able to override the default implementations of the desired functions.&lt;/p&gt;

&lt;p&gt;With both the dynamic library and the modified plist we can then restart CommCenter and watch our log file for anything of interest.  To restart CommCenter you can just run the &lt;code class=&quot;highlighter-rouge&quot;&gt;injectCommCenter.sh&lt;/code&gt; script which essentially just uses &lt;code class=&quot;highlighter-rouge&quot;&gt;launchctl&lt;/code&gt; to unload and load it.&lt;/p&gt;

&lt;h3 id=&quot;a-note-about-commcenter&quot;&gt;A Note About CommCenter&lt;/h3&gt;

&lt;p&gt;Beginning in iOS 6 (or earlier, I’m not entirely sure) Apple has created two versions of CommCenter: CommCenterClassic, and CommCenter.  Which is used depends on the hardware you are using.  For example, an iPhone 4 will use CommCenterClassic while an iPhone 5 will use CommCenter.  At this point it’s unclear to me what the difference is between the two; however, I have heard that newer devices use a different protocol to communicate with the baseband.&lt;/p&gt;

&lt;p&gt;Until next time, happy hacking!&lt;/p&gt;

&lt;p&gt;@lightbulbone&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Aug 2013 04:13:59 -0700</pubDate>
        <link>https://www.lightbulbone.com/2013/08/03/snooping-on-commcenter.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/08/03/snooping-on-commcenter.html</guid>
        
        
      </item>
    
      <item>
        <title>iOS Shared Cache Extraction</title>
        <description>&lt;p&gt;Having fallen off the iOS-exploration train due to completing my  Masters and other commitments, I have finally climbed back aboard in pursuit of understanding the telephony stack.&lt;/p&gt;

&lt;p&gt;Like most things in iOS that are used frequently, the vast majority of the frameworks and libraries used in the telephony stack reside in the dyld shared cache located at &lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armv7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this post I am going to explain how to go about extracting this cache file so that you can then work with each library individually.&lt;/p&gt;

&lt;h3 id=&quot;get-the-cache&quot;&gt;Get The Cache&lt;/h3&gt;

&lt;p&gt;The first step in all of this is to copy the cache over to your local machine.  I did this using a program called iExplorer, but you can just as easily do it over SSH.  As a side note, you can connect to your iDevice using SSH over USB if you install a tool called iProxy.&lt;/p&gt;

&lt;h3 id=&quot;building-dscextractor&quot;&gt;Building &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The easiest way I found to extract the cache is to use a program provided by Apple called &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.  You can get the source for &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; by downloading the dyld package from Apples open source page at: http://opensource.apple.com/.&lt;/p&gt;

&lt;p&gt;After downloading the package, unarchive it then go to the &lt;code class=&quot;highlighter-rouge&quot;&gt;launch-cache&lt;/code&gt; subdirectory.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy tmp]$ tar -xvzf dyld-210.2.3.tar.gz
[dean@zippy tmp]$ cd dyld-210.2.3/launch-cache/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point we need to apply a patch to the &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; code so that it can be compiled and function properly.  The patch to be applied is available on GitHub at https://gist.github.com/lightbulbone/6092321.&lt;/p&gt;

&lt;p&gt;The patch can be applied using the &lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt; command; once patched &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt; can then be compiled.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy launch-cache]$ patch &amp;lt; dsc_extractor.patch
[dean@zippy launch-cache]$ clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You should now have a working copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;extracting-the-cache&quot;&gt;Extracting The Cache&lt;/h3&gt;

&lt;p&gt;The last step is pretty simple.  All you need to do is run &lt;code class=&quot;highlighter-rouge&quot;&gt;dsc_extractor&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@zippy com.apple.dyld]$ dsc_extractor dyld_shared_cache_armv7 armv7/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you then look inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;armv7/&lt;/code&gt; folder you’ll find all the extracted libraries used on iOS.&lt;/p&gt;

&lt;p&gt;As a quick side note, you can also open the cache file directly in IDA Pro.  I found this be a bit cumbersome although you may have better luck.&lt;/p&gt;

&lt;p&gt;Until next time, happy hacking!&lt;/p&gt;

</description>
        <pubDate>Fri, 26 Jul 2013 07:27:00 -0700</pubDate>
        <link>https://www.lightbulbone.com/2013/07/26/ios-shared-cache-extraction.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/07/26/ios-shared-cache-extraction.html</guid>
        
        
      </item>
    
      <item>
        <title>Remote debugging with LLDB</title>
        <description>&lt;p&gt;The other day I was working on a project in Xcode and was getting fed up with it crashing and just not behaving.  So I set out on a mission to figure out how to remote debug an iOS app.  The secret to it all is LLDB, the LLVM Debugger.  LLDB is now the default debugger in Xcode (has been for awhile) and is a pretty powerful debugger complete with scripting in Python and many other hidden gems.&lt;/p&gt;

&lt;p&gt;To follow along you will need:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A jailbroken iDevice setup for development&lt;/li&gt;
  &lt;li&gt;Developer Tools (from Xcode) installed on a Mac&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At a high-level this approach works by running a little server on the iDevice and then connecting remotely from your Mac.  To begin, SSH into your iDevice and find some program of interest (such as an iOS app you may be developing).  Then start the debug server on your iDevice.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iPhone:/Applications/FieldTest.app root# /Developer/usr/bin/debugserver localhost:12345 ./FieldTest
debugserver-189 for armv7.
Listening to port 12345...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now on your Mac, we launch LLDB and then connect to the remote session.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[dean@simba ~]$ lldb
(lldb) platform select remote-ios
  Platform: remote-ios
 Connected: no
  SDK Path: &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/6.0.1 (10A523)&quot;
 SDK Roots: [ 0] &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/5.1.1 (9B206)&quot;
 SDK Roots: [ 1] &quot;/Users/dean/Library/Developer/Xcode/iOS DeviceSupport/6.0.1 (10A523)&quot;
(lldb) process connect connect://192.168.1.20:12345
Process 2237 stopped
* thread #1: tid = 0x1603, 0x2fe7a028 dyld`_dyld_start, stop reason = signal SIGSTOP
    frame #0: 0x2fe7a028 dyld`_dyld_start
dyld`_dyld_start:
-&amp;gt; 0x2fe7a028:  mov    r8, sp
   0x2fe7a02c:  sub    sp, sp, #16
   0x2fe7a030:  bic    sp, sp, #7
   0x2fe7a034:  ldr    r3, [pc, #112]            ; _dyld_start + 132
(lldb)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point you know have a remote connection to the process being debugged and can use LLDB as you would normally.  Note that this is the exact same way Xcode connects to an app being debugged so anything you can do in Xcode should be possible here.&lt;/p&gt;

&lt;p&gt;Enjoy and happy hacking!&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Jan 2013 11:32:54 -0800</pubDate>
        <link>https://www.lightbulbone.com/2013/01/08/remote-debugging-with-lldb.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2013/01/08/remote-debugging-with-lldb.html</guid>
        
        
      </item>
    
      <item>
        <title>Fuzzy iOS Messages!</title>
        <description>&lt;p&gt;Awhile ago I came across a post about fuzzing with a new data flow language called Pythonect.  When I read about it I thought it sounded like a pretty nifty language so I decided to try using it to fuzz the iMessage interface in the iOS Messages app.&lt;/p&gt;

&lt;p&gt;The first part of this task is to come up with a way to send messages to an iOS device using the iMessage service.  Luckily the new Messages app on OS X 10.8 has support for AppleScript and you can send messages through it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/usr/bin/osascript

on run argv
    set theMessage to (item 1 of argv)

    tell application &quot;Messages&quot;
         send theMessage to buddy &quot;BUDDY_NAME&quot;
    end tell
end run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this script we tell the Messages application to send a message that was given as an argument to the buddy &lt;code class=&quot;highlighter-rouge&quot;&gt;BUDDY_NAME&lt;/code&gt;.  When you use it be sure to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;BUDDY_NAME&lt;/code&gt; with the correct buddy name you are using.  Also, I saved the script and named it &lt;code class=&quot;highlighter-rouge&quot;&gt;send_msg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;From here it’s quite easy to use Pythonect to do some fuzzing.  For example, the following script will send groups of 4 and 8 A’s, B’s, C’s, and D’s.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;['A', 'B', 'C', 'D'] -&amp;gt; [_ * n for n in [4, 8]] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So what else can we do with Pythonect?  Well for starters you can increase the number of characters and messages sent effectively DoSing the device.  You could also mix and match characters to see what outcome that may arrive at.&lt;/p&gt;

&lt;p&gt;I haven’t had much time to play with this but I’ve found that running the following command seems to crash the device.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;['A', 'B', 'C', 'D', '*', '+', '\', '/'] -&amp;gt; [_ * n for n in [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000]] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And, this one causes the actual name of the app to be displayed.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;['*'] -&amp;gt; os.system(&quot;./send_msg &quot; + _)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So there is clearly something going on here, definitely stay tuned for what lurks within!&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Oct 2012 13:42:06 -0700</pubDate>
        <link>https://www.lightbulbone.com/2012/10/19/fuzzy-ios-messages.html</link>
        <guid isPermaLink="true">https://www.lightbulbone.com/2012/10/19/fuzzy-ios-messages.html</guid>
        
        
      </item>
    
  </channel>
</rss>
